<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git学习笔记</title>
    <url>/2021/11/13/Git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a><center>Git学习笔记</center></h2><p>[TOC]</p>
<h3 id="一、git常用命令"><a href="#一、git常用命令" class="headerlink" title="一、git常用命令"></a>一、git常用命令</h3><h4 id="1、初始化分支（git-init）"><a href="#1、初始化分支（git-init）" class="headerlink" title="1、初始化分支（git init）"></a>1、初始化分支（<code>git init</code>）</h4><ul>
<li>在初始化分支后，需要提交内容后才能创建分支，否则会出现<code>fatal: 不是一个有效的对象名：&#39;master&#39;</code>错误</li>
</ul>
<h4 id="2、添加远程仓库（git-remote）"><a href="#2、添加远程仓库（git-remote）" class="headerlink" title="2、添加远程仓库（git remote）"></a>2、添加远程仓库（<code>git remote</code>）</h4><ul>
<li><p><strong>添加远程库</strong></p>
<p><code>git remote add origin git@github.com:xxx/xxx.git</code></p>
<ul>
<li><p>使用<code>token</code></p>
<p><code>git remote add origin https://&lt;token&gt;@github.com/xxx/xxx.git</code></p>
</li>
</ul>
<p><code>origin</code>为取的名字</p>
</li>
<li><p><strong>清除远程库</strong></p>
<p><code>git remote rm origin</code></p>
</li>
</ul>
<h4 id="3、克隆远程库（git-clone）"><a href="#3、克隆远程库（git-clone）" class="headerlink" title="3、克隆远程库（git clone）"></a>3、克隆远程库（<code>git clone</code>）</h4><ul>
<li><code>git clone git@github.com:xxx/xxx.git</code></li>
<li><code>git clone https://github.com:xxx/xxx.git</code></li>
</ul>
<h4 id="4、查看log（git-log）"><a href="#4、查看log（git-log）" class="headerlink" title="4、查看log（git log）"></a>4、查看log（<code>git log</code>）</h4><ul>
<li><code>git log</code>：查看commit id<ul>
<li><code>git log --graph</code>：图形化显示分支</li>
</ul>
</li>
<li><code>git reflog</code>：查看所有提交过的commit id，包括删除过的</li>
</ul>
<h4 id="5、分支操作（git-branch）"><a href="#5、分支操作（git-branch）" class="headerlink" title="5、分支操作（git branch）"></a>5、分支操作（<code>git branch</code>）</h4><p> 提交代码前最好创建本地分支</p>
<ul>
<li><p><strong>新建分支</strong></p>
<p><code>git checkout -b &lt;name&gt;</code>（相当于以下两条命令）</p>
<ul>
<li><code>git branch dev</code>创建分支<br><code>git checkout dev</code>切换分支</li>
</ul>
</li>
<li><p><strong>重命名分支</strong></p>
<p><code>git branch -m &lt;oldName&gt; &lt;newName&gt;</code></p>
</li>
<li><p><strong>查看分支</strong></p>
<p><code>git branch -l</code></p>
<p><code>git branch</code> 查看本地分支（<code>git branch -r</code> 查看远程分支，<code>git branch -a</code>查看所有分支）</p>
</li>
<li><p><strong>切换分支</strong></p>
<p><code>git checkout &lt;name&gt;</code></p>
</li>
<li><p><strong>合并分支</strong></p>
<ul>
<li><p><code>git merge &lt;name&gt;</code></p>
<blockquote>
<p>直接把两个分支再各自拉出一条线，然后连在一起</p>
<p>最后会有两次提交，有分叉，会产生<code>Merge branch xxx of xxx</code>提交</p>
</blockquote>
</li>
<li><p><code>git rebase</code></p>
<blockquote>
<p>将当前分支与要合并的分支中不同的commits取消掉，临时保存起来，然后在要合并的分支中再把保存起来的commits patch上去，变成新的commits</p>
<p>最后就只剩合并后的分支，是一条直线，没有分叉，不会有<code>Merge branch xxx of xxx</code>提交</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>删除分支</strong></p>
<p><code>git branch -d &lt;name&gt;</code></p>
</li>
<li><p><strong>建立本地分支和远程分支的关联</strong></p>
<p><code>git branch --set-upstream-to=origin/&lt;远程分支&gt; &lt;本地分支&gt;</code></p>
</li>
</ul>
<h4 id="6、拉取代码（fetch-amp-pull）"><a href="#6、拉取代码（fetch-amp-pull）" class="headerlink" title="6、拉取代码（fetch&amp;pull）"></a>6、拉取代码（<code>fetch&amp;pull</code>）</h4><ul>
<li><p><code>git fetch</code>：将远程commit拉取到本地</p>
<p><code>git fetch origin &lt;分支名&gt;</code>：若不指定分支名，默认为<code>master</code>分支</p>
<blockquote>
<p><code>fetch</code>不会直接将拉取的commit接到本地分支的最后，而是在本地最后一次==push的commit处==再拉取一个新的分支</p>
</blockquote>
</li>
<li><p><code>git pull</code>：拉取并合并分支</p>
<blockquote>
<p>用于从远程获取代码并合并本地的版本</p>
</blockquote>
<p><code>git pull</code>其实就是 <code>git fetch</code> 和 <code>git merge FETCH_HEAD</code>的简写</p>
</li>
<li><p><code>git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
<ul>
<li>拉取origin的远程分支与本地分支合并</li>
</ul>
</li>
<li><p>==本地未修改==，只有master分支，直接更新</p>
<ul>
<li><code>git pull</code><ul>
<li>若修改后直接pull，会产生冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>本地分支有修改，多分支</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;主分支&gt;</span><br><span class="line">git pull</span><br><span class="line">git checkout &lt;子分支&gt;</span><br><span class="line">git merger &lt;主分支&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="7、添加暂存库（git-add）"><a href="#7、添加暂存库（git-add）" class="headerlink" title="7、添加暂存库（git add）"></a>7、添加暂存库（<code>git add</code>）</h4><ul>
<li><p><code>git add</code>：把修改的文件提交到暂存区</p>
</li>
<li><p><code>git add -A</code>：提交所有变化</p>
</li>
<li><p><code>git add -u</code> ：提交被修改和被删除文件，不包括新文件</p>
</li>
<li><p><code>git add .</code> ：提交新文件和被修改文件，不包括被删除文件</p>
</li>
<li><p><code>git add -p</code>：<a href="https://www.cnblogs.com/zqb-all/p/13020293.html" target="_blank" rel="noopener">使用 git add -p 整理 patch</a></p>
<blockquote>
<p><code>-p</code>, <code>--patch</code> 交互地在索引和工作树之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。</p>
<p>这可以有效地运行 add –interactive，但是会绕过初始命令菜单，而直接跳转到 patch 子命令。有关详细信息，请参见`‘交互模式’’。</p>
</blockquote>
<p>能够交互式选择代码片段，选择需要<code>add</code>的代码片段</p>
<ul>
<li><p>输入<code>git add -p</code>进入<code>patch mode</code>，此时<code>git</code>会自动将改动切分成多个片段，并展示第一个片段，提示进行选择；提示语句：<code>Stage this hunk [y, n, q, a, d, /, s, e, ?]</code></p>
<p>| 字符 | 含义                             |<br>| —- | ——————————– |<br>| <code>y</code>  | 暂存此块                         |<br>| <code>n</code>  | 不暂存此块                       |<br>| <code>q</code>  | 退出，不暂存此块与剩余区块       |<br>| <code>a</code>  | 暂存此块与文件后面的所有的区块   |<br>| <code>d</code>  | 不暂存此块与此文件后面所有的区块 |<br>| <code>g</code>  | 选择并跳转至一个区块             |<br>| <code>/</code>  | 搜索与给定正则表达式匹配的区块   |<br>| <code>j</code>  | 暂不决定，转至下一个未决定的区块 |<br>| <code>J</code>  | 暂不决定，转至下一个区块         |<br>| <code>k</code>  | 暂不决定，转至上一个未决定的区块 |<br>| <code>K</code>  | 暂不决定，转至上一个区块         |<br>| <code>s</code>  | 将当前区块划分成多个较小的区块   |<br>| <code>e</code>  | 手动编辑当前的区块               |<br>| <code>？</code> | 显示帮助                         |</p>
</li>
<li><p>挑选完后，使用<code>git diff --cached</code>确认，或者在提交之后<code>git show</code>确认改动</p>
</li>
</ul>
</li>
</ul>
<h4 id="8、提交到本地仓库（git-commit）"><a href="#8、提交到本地仓库（git-commit）" class="headerlink" title="8、提交到本地仓库（git commit）"></a>8、提交到本地仓库（<code>git commit</code>）</h4><ul>
<li><p><code>git commit -m &quot;message&quot;</code></p>
<ul>
<li>使用<code>-m</code> 参数，可以直接在引号中输入备注</li>
<li>不使用<code>-m</code>参数，会打开vim，在vim中编辑备注</li>
</ul>
</li>
<li><p><code>git commit -a -m &quot;message&quot;</code></p>
<ul>
<li><code>-a</code>参数：把还没有执行add命令的修改一起提交</li>
</ul>
</li>
<li><p><code>git commit --amend</code></p>
<ul>
<li><p>将多次提交合并为一次，追加此次提交到上一次提交的<code>commit id</code>中，而不会增加新的<code>commit id</code></p>
</li>
<li><p>==如果在已提交到远程仓库的commit上追加<code>amend</code>，会造成远程分支与本地分支不一致，需要重新拉取合并分支后再push==</p>
<p><strong><code>--amend</code>一般应用于没有push到远程分支的<code>commit</code>上</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="9、提交到远程仓库（git-push）"><a href="#9、提交到远程仓库（git-push）" class="headerlink" title="9、提交到远程仓库（git push）"></a>9、提交到远程仓库（<code>git push</code>）</h4><p>提交到远程分支</p>
<blockquote>
<p>origin 为添加远程仓库时所取名字</p>
</blockquote>
<ul>
<li><p><strong>提交到远程分支</strong></p>
<ul>
<li><p><code>git push origin &lt;branch name&gt;</code>：提交指定分支</p>
</li>
<li><p><code>git push -u origin &lt;branch name&gt;</code>：将分支提交到<code>origin</code>，同时指定<code>origin</code>为默认主机</p>
<p><code>-u</code>：指定默认主机，后面提交时可以直接使用<code>git push</code>，不带<code>origin</code>与分支名</p>
</li>
</ul>
</li>
<li><p><strong>提交到<code>Gerrit</code>中</strong></p>
<p><code>git push origin HEAD:refs/for/&lt;分支名&gt;</code></p>
</li>
<li><p><strong>提交到<code>Gerrit</code>中</strong></p>
<p><code>git push origin HEAD:refs/for/&lt;branch name&gt;</code></p>
<ul>
<li><code>origin</code> : 代表远程仓库</li>
<li><code>HEAD</code>：本地当前分支</li>
<li><code>&lt;分支名&gt;</code>: 需要push到远程的分支名</li>
<li><code>refs/for</code>：代表需要经过<code>gerrit</code>上进行<code>review</code>，而不是直接提交到仓库中</li>
</ul>
</li>
<li><p><strong>强制提交</strong>，覆盖远程仓库代码</p>
<ul>
<li><code>git push --force origin &lt;分支名&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="10、回退版本（git-reset）"><a href="#10、回退版本（git-reset）" class="headerlink" title="10、回退版本（git reset）"></a>10、回退版本（<code>git reset</code>）</h4><ul>
<li><p><strong>取消在暂存区中的某个文件</strong></p>
<p><code>git reset HEAD &lt;filename&gt;</code></p>
</li>
<li><p><strong>取消暂存当前路径下所有的文件</strong></p>
<p><code>git reset HEAD .</code></p>
</li>
<li><p><strong>取消最近的n次提交或退至指定<code>commit id</code></strong></p>
<p><code>git reset HEAD~n</code> 或 <code>git reset &lt;commit id&gt;</code></p>
<ul>
<li>同步指定的commit id的内容到当前，==不包含提交==。（即回退到commit id版本，但修改<strong>不会被<code>commit</code></strong>到本地仓库）</li>
</ul>
<p><code>git reset --hard HEAD~n</code> 或 <code>git reset &lt;commit id&gt;</code></p>
<ul>
<li>同步指定的commit id的内容到当前，==包含提交==。（即回退到commit id版本，但修改<strong>会被<code>commit</code></strong>到本地仓库）</li>
</ul>
</li>
</ul>
<h4 id="11、移除（git-clean）"><a href="#11、移除（git-clean）" class="headerlink" title="11、移除（git clean）"></a>11、移除（<code>git clean</code>）</h4><ul>
<li><p><code>git clean -f &lt;filename&gt;</code>：移除工作区的某个文件</p>
</li>
<li><p><code>git clean -df</code>：移除工作区所有未追踪文件</p>
</li>
</ul>
<h4 id="12、撤销（git-checkout）"><a href="#12、撤销（git-checkout）" class="headerlink" title="12、撤销（git checkout）"></a>12、撤销（<code>git checkout</code>）</h4><ul>
<li><p><strong>撤销工作区（还未添加至暂存区）某个文件的修改</strong></p>
<p><code>git checkout &lt;filename&gt;</code></p>
<p><code>git checkout .</code></p>
</li>
<li><p><strong>撤销添加到暂存区的文件</strong></p>
<p>使用<code>git reset HEAD &lt;filename&gt;</code>命令</p>
</li>
<li><p><strong>撤销添加至本地仓库的文件</strong></p>
<p>进行版本回退<code>git reset HEAD~1</code>或<code>git reset &lt;commit id&gt;</code></p>
</li>
</ul>
<h4 id="13、删除（git-rm）"><a href="#13、删除（git-rm）" class="headerlink" title="13、删除（git rm）"></a>13、删除（<code>git rm</code>）</h4><ul>
<li><p>将文件从<strong>暂存区和工作区</strong>删除</p>
<p><code>git rm &lt;filename&gt;</code></p>
</li>
<li><p>强行从暂存区和工作区中删除修改后的文件</p>
<p><code>git rm -f &lt;filename&gt;</code></p>
</li>
<li><p>将文件<strong>从暂存区删除</strong>，但<strong>保留在工作区</strong>中（仅从跟踪清单中删除）</p>
<p><code>git rm --cached &lt;filename&gt;</code></p>
</li>
<li><p><strong>递归删除</strong></p>
<p><code>git rm -r &lt;directory&gt;</code></p>
</li>
</ul>
<h4 id="14、查看文件差异（git-diff）"><a href="#14、查看文件差异（git-diff）" class="headerlink" title="14、查看文件差异（git diff）"></a>14、查看文件差异（<code>git diff</code>）</h4><ul>
<li><p><strong>查看修改后与原文件的不同</strong></p>
<p><code>git diff</code></p>
</li>
<li><p><strong>查看已经暂存起来的文件和上次提交的文件的差异</strong></p>
<p><code>git diff --cached</code></p>
<p><code>git diff --staged</code></p>
<ul>
<li>显示的是下一次commit时会提交到HEAD的内容(不带-a情况下)</li>
</ul>
</li>
<li><p>查看简单的<code>diff</code>结果，可以加上<code>--stat</code>参数</p>
<p><code>git diff --stat</code></p>
</li>
<li><p><strong>图像化查看不同</strong></p>
<p><code>git difftool</code></p>
<ul>
<li><code>difftool</code>需要配置</li>
</ul>
</li>
<li><p><strong>本地分支与远程分支比较</strong></p>
<ul>
<li><p>显示远程分支与本地分支差异</p>
<p><code>git diff &lt;remote-branch&gt; &lt;local-branch&gt;</code></p>
</li>
<li><p>仅显示远程分支与本地分支文件名差异</p>
<p><code>git diff --name-status &lt;remote-name&gt; &lt;local-name&gt;</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="15、变基操作（git-rebase）"><a href="#15、变基操作（git-rebase）" class="headerlink" title="15、变基操作（git rebase）"></a>15、变基操作（<code>git rebase</code>）</h4><table>
<thead>
<tr>
<th><code>rebase</code>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p, pick</code></td>
<td>使用提交</td>
</tr>
<tr>
<td><code>r, reword</code></td>
<td>使用提交，但修改提交说明</td>
</tr>
<tr>
<td><code>e, edit</code></td>
<td>使用提交，但停止以便进行提交修补</td>
</tr>
<tr>
<td><code>s, squash</code></td>
<td>使用提交，但和前一个版本融合</td>
</tr>
<tr>
<td><code>f, fixup</code></td>
<td>类似于 “squash”，但丢弃提交说明日志</td>
</tr>
<tr>
<td><code>x, exec</code></td>
<td>使用 shell 运行命令（此行剩余部分）</td>
</tr>
<tr>
<td><code>d, drop</code></td>
<td>删除提交</td>
</tr>
</tbody>
</table>
<p><a href="https://www.jianshu.com/p/4a8f4af4e803" target="_blank" rel="noopener">【Git】rebase 用法小结</a></p>
<p>==<strong>不要通过<code>rebase</code>对任何已经提交到公共仓库中的commit进行修改</strong>==</p>
<blockquote>
<p>可以对某一段线性提交历史进行编辑、删除、复制、粘贴</p>
</blockquote>
<ul>
<li><p><strong>合并多个commit为一个完整commit</strong></p>
<ol>
<li><p><code>git rebase -i  [startpoint]  [endpoint]</code></p>
<ul>
<li><p><code>-i</code>：<code>--interactive</code>，弹出交互式的界面让用户编辑完成合并操作</p>
</li>
<li><p><code>[startpoint]</code> <code>[endpoint]</code>：指定了一个编辑区间</p>
<p>若不指定<code>[endpoint]</code>，则该区间默认终点为当前分支<code>HEAD</code>所指的<code>commit</code></p>
</li>
</ul>
</li>
<li><p>将<code>pick</code>改为<code>s</code>（<code>squash</code>）</p>
</li>
</ol>
</li>
<li><p><strong>将某一段commit粘贴到另一个分支上</strong></p>
<ol>
<li><p><code>git rebase   [startpoint]   [endpoint]  --onto  [branchName]</code></p>
<p><strong>注：</strong><code>[startpoint]   [endpoint]</code>：指定的是一个<strong>前开后闭</strong>的区间，<code>startpoint</code>应当为要包含commit的前一个</p>
</li>
<li><p>切换到<code>branchName</code></p>
</li>
<li><p>将<code>branchName</code>所指的<code>commit_id</code>设置为当前<code>HEAD</code>所指的<code>commit_id</code>：<code>git reset --hard commit_id</code></p>
</li>
</ol>
</li>
</ul>
<h4 id="16、保存工作区内容（git-stash）"><a href="#16、保存工作区内容（git-stash）" class="headerlink" title="16、保存工作区内容（git stash）"></a>16、保存工作区内容（<code>git stash</code>）</h4><ul>
<li><p><strong>将工作区的修改临时保存在暂存区</strong></p>
<p><code>git stash</code></p>
</li>
<li><p><strong>将暂存区的内容恢复到工作区</strong></p>
<p><code>git stash pop</code></p>
<p><code>git stash apply</code></p>
</li>
<li><p><strong>查看暂存区有哪些临时修改</strong></p>
<p><code>git stash list</code></p>
</li>
<li><p><strong>丢弃暂存区的修改</strong></p>
<p><code>git stash drop stash@{$num}</code></p>
<p><code>git stash clear</code></p>
</li>
</ul>
<h4 id="17、标签（git-tag）"><a href="#17、标签（git-tag）" class="headerlink" title="17、标签（git tag）"></a>17、标签（<code>git tag</code>）</h4><ul>
<li><p><strong>创建标签</strong></p>
<p><code>git tag &lt;tag name&gt;</code></p>
<ul>
<li>标签默认打在最新的<code>commit</code>（<code>HEAD</code>）上</li>
</ul>
</li>
<li><p><strong>指定要创建的标签的位置</strong></p>
<p><code>git tag &lt;tag name&gt; &lt;commit id&gt;</code></p>
</li>
<li><p><strong>新建带有标签的tag</strong></p>
<p><code>git tag -a &lt;tag name&gt; -m &quot;&quot;</code></p>
</li>
<li><p><strong>获取tag列表</strong></p>
<p><code>git tag -l</code></p>
</li>
<li><p><strong>查看具体tag</strong></p>
<p><code>git show &lt;tag name&gt;</code></p>
</li>
<li><p><strong>删除tag</strong></p>
<p><code>git tag -d &lt;tag name&gt;</code></p>
</li>
</ul>
<h4 id="18、patch（git-format-patch-amp-git-am）"><a href="#18、patch（git-format-patch-amp-git-am）" class="headerlink" title="18、patch（git format-patch&amp;git am）"></a>18、<code>patch</code>（<code>git format-patch</code>&amp;<code>git am</code>）</h4><p><a href="https://blog.csdn.net/liuhaomatou/article/details/54410361" target="_blank" rel="noopener">如何使用git 生成patch 和打入patch</a></p>
<ul>
<li><strong>生成patch</strong><ul>
<li><code>git format-patch &lt;commit_id&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="二、git操作"><a href="#二、git操作" class="headerlink" title="二、git操作"></a>二、git操作</h3><h4 id="1、提交当前工作区内容至指定的Commit-id"><a href="#1、提交当前工作区内容至指定的Commit-id" class="headerlink" title="1、提交当前工作区内容至指定的Commit-id"></a>1、提交当前工作区内容至指定的Commit-id</h4><blockquote>
<p>在<code>typora</code>中需要重新打开才能看见提交的内容</p>
</blockquote>
<ol>
<li><p>保存当前工作区内容</p>
<p><code>git stash</code></p>
</li>
<li><p>修改commit内容，将HEAD指针指向需要更改的commit上</p>
<p><code>git rebase -i commit_id^</code></p>
<p><code>-i</code>：<code>--interactive</code>，弹出交互式的界面让用户编辑完成合并操作    </p>
<p>找到需要更改的<code>commit</code>，将行首的<code>pick</code>改为<code>edit</code></p>
</li>
<li><p>取出<code>stash</code>中的工作</p>
<p><code>git stash pop</code></p>
</li>
<li><p>添加至暂存库</p>
<p><code>git add &lt;filename&gt;</code></p>
</li>
<li><p>追加到指定的<code>commit</code>中</p>
<p><code>git commit --amed</code></p>
</li>
<li><p>移动HEAD指针到最新的<code>commit</code>处</p>
<p><code>git rebase --continue</code></p>
<p>若有冲突：</p>
<ul>
<li>解决冲突后add，再追加</li>
<li>再用<code>git rebase --continue</code>将HEAD指针移动至最新的commit处</li>
</ul>
</li>
</ol>
<h4 id="2、git在命令行中正确显示中文文件名"><a href="#2、git在命令行中正确显示中文文件名" class="headerlink" title="2、git在命令行中正确显示中文文件名"></a>2、git在命令行中正确显示中文文件名</h4><p>在命令行输入<code>git config --global core.quotepath off</code></p>
<blockquote>
<p>将<code>core.quotepath</code>设为false，不会对<code>0x80</code>以上的字符进行quote</p>
</blockquote>
<h4 id="3、github怎么邀请合作者加入到自己的项目"><a href="#3、github怎么邀请合作者加入到自己的项目" class="headerlink" title="3、github怎么邀请合作者加入到自己的项目"></a>3、<code>github</code>怎么邀请合作者加入到自己的项目</h4><p><a href="https://jingyan.baidu.com/article/948f5924f43f47d80ff5f9f9.html" target="_blank" rel="noopener"><code>github</code>怎么邀请合作者加入到自己的项目</a></p>
<blockquote>
<p>登录<code>github</code>-&gt;选择项目-&gt;setting-&gt;Manage access-&gt;通过邮件、用户名等添加用户</p>
<p>被邀请人在<code>github</code>账号头像处查看邀请信息</p>
</blockquote>
<h4 id="4、github添加token"><a href="#4、github添加token" class="headerlink" title="4、github添加token"></a>4、<code>github</code>添加token</h4><p><a href="https://www.pianshen.com/article/9592754254/" target="_blank" rel="noopener">关于<code>github</code>中的token的创建方法</a></p>
<blockquote>
<p><code>github</code>用户setting -&gt;Developer settings–&gt;Personal access tokens–&gt;Generate token</p>
</blockquote>
<h4 id="3、本地有修改提交到远程，但不确定是否与远程有冲突"><a href="#3、本地有修改提交到远程，但不确定是否与远程有冲突" class="headerlink" title="3、本地有修改提交到远程，但不确定是否与远程有冲突"></a>3、本地有修改提交到远程，但不确定是否与远程有冲突</h4><blockquote>
<p><code>git push</code>有冲突提交，不产生合并记录提交</p>
</blockquote>
<ol>
<li><p>本地添加提交（<code>add commit</code>）</p>
</li>
<li><p><code>git fetch origin</code></p>
</li>
<li><p><code>git rebase origin/&lt;branch-name&gt;</code></p>
</li>
<li><p>若有冲突：</p>
<ul>
<li>解决冲突后<code>git add</code></li>
<li><code></code>git rebase –continue`</li>
</ul>
</li>
<li><p><code>git push</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象</title>
    <url>/2019/10/20/python%E7%AC%94%E8%AE%B03(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="一、面向对象编程"><a href="#一、面向对象编程" class="headerlink" title="一、面向对象编程"></a>一、面向对象编程</h3><hr>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。把大块函数通过切割成小函数来降低系统的复杂度</p>
<p>面向对象的程序设计把计算机程序视为一组对象的集合，计算机执行的就是一系列消息在各个对象之间传递</p>
<p>面向对象的数据思想是抽象出Class，根据Class创建Instance（实例）</p>
<p>一个Class既包含数据，又包含操作数据的方法</p>
<h4 id="1、类和实例"><a href="#1、类和实例" class="headerlink" title="1、类和实例"></a>1、类和实例</h4><ol>
<li><p><strong>定义类：</strong></p>
<p><code>class Student(object):</code></p>
<p><code>(object)</code>表示该类从哪个类继承，如果没有合适的继承类，就使用<code>object</code>类(所有类都会继承的类)</p>
</li>
<li><p><strong>创建实例：</strong></p>
<p><code>类名+()</code>实现:<code>bart = Studen()</code></p>
<p>通过一个特殊的<code>__init__</code>方法，在创建实例的时候就把一些必须的属性加上去</p>
<p><code>def __init__(self,name,score):</code> </p>
<p><code>__init__</code>的第一个参数必须是self，表示创建实例的本身，传入参数<code>self</code>时不需要传</p>
</li>
<li><p><strong>数据封装</strong></p>
<p>在类的内部定义访问数据的函数</p>
</li>
</ol>
<p>==方法就是与实例绑定的函数，方法可以直接访问数据的实例==</p>
<h4 id="2、访问限制"><a href="#2、访问限制" class="headerlink" title="2、访问限制"></a>2、访问限制</h4><ul>
<li><p>设为私有来限制访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.__name =name</span><br><span class="line">		self.__age = age</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_name</code>外部可以直接访问，但按约定，不直接进行访问</p>
</li>
<li><p><code>__name</code>不能被访问的原因是python解释器对外把<code>__name</code>变量改为了<code>_Student__name</code>（不同版本的python改成不同的变量名）</p>
</li>
</ul>
<p>==Python本身没有任何机制不阻止你干坏事，一切靠自觉==</p>
<h4 id="3、继承和多态"><a href="#3、继承和多态" class="headerlink" title="3、继承和多态"></a>3、继承和多态</h4><p><code>class Dog(Animal):</code></p>
<p>子类获得父类的全部功能</p>
<p>当子类与父类同时存在相同的方法，子类会覆盖父类的方法</p>
<p>开闭原则：</p>
<ul>
<li>对扩展开发：允许增加新的子类</li>
<li>对修改封闭</li>
</ul>
<h4 id="4、获取对象信息"><a href="#4、获取对象信息" class="headerlink" title="4、获取对象信息"></a>4、获取对象信息</h4><p><strong>（1）<code>type()</code>：查看对象类型，==返回==对应的==class类型==</strong></p>
<ul>
<li><p>基本类型都可以用<code>type()</code>判断</p>
<p>例：<code>type(123)</code>、<code>type(&#39;str&#39;)</code></p>
<ul>
<li><p>判断基本数据类型可以直接写<code>int</code>、<code>char</code></p>
<p><code></code>type(123) == int`</p>
</li>
</ul>
</li>
<li><p>一个变量指向函数或者类，也可以用<code>type()</code>判断</p>
<p>例：<code>type(abs)</code>、<code>type(a)</code></p>
<ul>
<li><p>判断一个对象是否是函数（可以使用type模块中定义的常量）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import types</span><br><span class="line">def fn():</span><br><span class="line">	pass</span><br><span class="line">print(type(fn) == types.FunctionsType)</span><br><span class="line">print(type(abs) == types.BuiltFunctionType)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>（2）<code>isinstance()</code>：判断一个对象是否是==该类型本身==或者位于该类型的==父继承链上==</strong></p>
<ul>
<li><p>判断继承</p>
<p>如果继承关系为：</p>
<p><code>object-&gt;Animal-&gt;Dog</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = Animal()</span><br><span class="line">d = Dog()</span><br><span class="line">isinstance(d,Dog)</span><br><span class="line">isinstance(d,Animal)</span><br></pre></td></tr></table></figure>
</li>
<li><p>与<code>type()</code>一样判断基本类型</p>
<p><code>isinstance(&#39;a&#39;,str)</code></p>
</li>
<li><p>判断一个变量是否是某些类型中的一种</p>
<p><code>isinstance([1,2,3],(list,tuple))</code></p>
</li>
</ul>
<p>==优先使用instance==</p>
<p><strong>（3）<code>dir()</code>：获取对象的所有属性和方法，==返回==一个包含字符串的==list==</strong></p>
<ul>
<li><p>直接操作对象的状态，获得对象的方法</p>
<ul>
<li><p>获取属性：<code>getattr()</code>：<code>getattr(obj,&#39;x&#39;)</code></p>
<p>可以传入default参数，如果参数不存在，返回默认值</p>
<p><code>getattr(obi,&#39;x&#39;,404)</code> #不存在返回404</p>
</li>
<li><p>设置属性：<code>setattr()</code>：<code>setattr(obj,&#39;y&#39;,19)</code></p>
</li>
<li><p>查看属性：<code>hasattr()</code>：<code>hasattr(obj,&#39;y&#39;)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="二、实例属性和类属性"><a href="#二、实例属性和类属性" class="headerlink" title="二、实例属性和类属性"></a>二、实例属性和类属性</h3><hr>
<ul>
<li><p><strong>实例属性：</strong></p>
<p>实例属性属于各个实例所有，互不干扰</p>
</li>
<li><p><strong>类属性：</strong></p>
<p>类本身绑定属性，在class中直接定义属性，类属性属于类所有，所有实例共享一个属性</p>
</li>
</ul>
<p>==不要对实例属性和类属性使用相同的名字，实例属性会将类属性屏蔽掉==</p>
<h3 id="三、面向对象高级编程"><a href="#三、面向对象高级编程" class="headerlink" title="三、面向对象高级编程"></a>三、面向对象高级编程</h3><hr>
<h4 id="1、使用-slots-方法"><a href="#1、使用-slots-方法" class="headerlink" title="1、使用__slots__方法"></a>1、使用<code>__slots__</code>方法</h4><ul>
<li><p>给实例绑定方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def set_age(self,age): #定义一个函数作为实例方法</span><br><span class="line">	self.age = age</span><br><span class="line">from types import Methodtype</span><br><span class="line">s.set_age = MethodType(set_age,s) #给实例绑定一个方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>给class绑定方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def set_score(self,score):</span><br><span class="line">	self.score = score</span><br><span class="line">Student.set_score = set_score</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>__slots__</code>：</strong>限制该实例的能添加的==属性==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	__slots__ = (&apos;name&apos;,&apos;age&apos;) #用tuple定义允许绑定的属性名称</span><br></pre></td></tr></table></figure>
<p><code>__slots__</code>定义的属性仅==对当前类的实例起作用，对继承的子类不起作用==</p>
<p>想在子类中运用，就需在子类中也定义<code>__slots__</code>，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code></p>
</li>
</ul>
<h4 id="2、使用-property"><a href="#2、使用-property" class="headerlink" title="2、使用@property"></a>2、使用<code>@property</code></h4><ul>
<li><p>定义读写属性：定义<code>getter</code>和<code>setter</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	</span><br><span class="line">	@property		#getter方法</span><br><span class="line">	def birth(self):</span><br><span class="line">		return self._birth</span><br><span class="line">	</span><br><span class="line">	@birth.setter    #setter方法</span><br><span class="line">	def birth(self,value):</span><br><span class="line">		self._birth = value</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义只读属性：只定义<code>setter</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	</span><br><span class="line">	@property</span><br><span class="line">	def age(self):</span><br><span class="line">		return 2015-self._birth</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3、多重继承"><a href="#3、多重继承" class="headerlink" title="3、多重继承"></a>3、多重继承</h4><ul>
<li><p><strong><code>MixIn</code></strong></p>
<p>多重继承：一个子类同时继承多个父类（<code>class Bat(Mammal,Flyable)</code>）</p>
<p><code>MixIn</code>:（mix+in：混入）给一个类增加多个功能（继承多个父类）</p>
<p>优先通过多重继承来组合多个<code>Mixln</code>的功能</p>
</li>
</ul>
<h4 id="4、定制类"><a href="#4、定制类" class="headerlink" title="4、定制类"></a>4、定制类</h4><ul>
<li><p><strong><code>__str__</code>：返回字符串</strong></p>
<p>定义<code>__str__</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def __str__(self):</span><br><span class="line">	return &apos;Student object (name:%s)&apos; % self.name</span><br></pre></td></tr></table></figure>
<p> 直接显示变量调用的不是<code>__str__()</code>,而是<code>__repr__()</code></p>
<ul>
<li><code>__str__()</code>返回用户看到的字符串<code>Student object (name:micle)</code></li>
<li><code>__repr__()</code>返回开发者看到的字符串<code>&lt;__main__.Student object at 0x109afb310&gt;</code></li>
<li>解决办法：<code>__repr__ = __str__</code></li>
</ul>
</li>
<li><p><strong><code>__iter__</code>：循环类</strong></p>
<p>==iter：循环==</p>
<p>类想被<code>for...in</code>循环，就必须实现一个<code>__iter__()</code>方法，改方法返回一个迭代对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.a,self.b = 0,1</span><br><span class="line">	def __iter__(self):</span><br><span class="line">		return self   #实例本身是迭代对象，故返回自己</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>__getitem__</code>：类按下标访问元素</strong></p>
<p>==item：==</p>
<p>按照下标取出元素：<code>__getitem__()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">	def __getitem__(self,n):</span><br><span class="line">		a,b=1,1</span><br><span class="line">		for x in range(n):</span><br><span class="line">			a,b = b,a+b</span><br><span class="line">		return a</span><br></pre></td></tr></table></figure>
<p>对Fib切片会报错，原因是<code>__getitem__()</code>传入的可能是一个int，也可能是一个切片对象slice</p>
<p>所以需要对传入的参数做判断<code>if isinstance(n,slice)</code></p>
</li>
<li><p><strong><code>__getattr__</code>：避免调用类的方法或属性不存在报错</strong></p>
<p>==attr：属性==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def __getattr__(self,attr)</span><br><span class="line">	if attr == &apos;age&apos;:</span><br><span class="line">		return 99   		#返回score的值</span><br><span class="line">		#return lambda: 25	#也可以返回函数</span><br></pre></td></tr></table></figure>
<p>只有在没有找到属性的情况下，才调用<code>__getattr__</code></p>
<p><code>__getattr__()</code>默认返回时<code>None</code></p>
<p>要让class只响应特定的几个属性，就需要抛出<code>AttributeError</code>（把一个类的所有属性和方法调用全部动态化处理了）</p>
</li>
<li><p><strong><code>__call__</code>：对实例进行调用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	def __init__(self,name):</span><br><span class="line">		self.name = name</span><br><span class="line">		</span><br><span class="line">	def __call__(self):</span><br><span class="line">		print(&apos;.....&apos;)</span><br></pre></td></tr></table></figure>
<p><code>__call__()</code> 还可以定义参数：<code>def __call__(self,age)</code></p>
<p><strong>判断一个对象能否被调用：</strong></p>
<p>能被调用的对象就是一个<code>Callable</code>对象:<code>callable(Student())</code></p>
<p><a href="http://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">Python的官方文档</a></p>
</li>
</ul>
<h4 id="5、使用枚举类Enum"><a href="#5、使用枚举类Enum" class="headerlink" title="5、使用枚举类Enum()"></a>5、使用枚举类<code>Enum()</code></h4><ul>
<li><p>使用<code>Enum()</code></p>
<p><code>from enum import Enum</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for name,member in Month__members__.item():</span><br><span class="line">	print(name,&apos;=&gt;&apos;,&apos;,&apos;,member.value)</span><br></pre></td></tr></table></figure>
<p><code>value</code>属性则是自动赋值给成员的<code>int</code>常量，默认从1开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from enum import Enum,unique</span><br><span class="line">@nuique</span><br><span class="line">class Weekday(Enum)</span><br></pre></td></tr></table></figure>
<p><code>@unique</code>装饰器可以保证没有重复值</p>
</li>
<li><p>访问枚举类型</p>
<ul>
<li>可以用成员名引用枚举常量（<code>Weekday.Tue</code>）</li>
<li>也可以直接根据value的值获得枚举常量（<code>Weekday(1)</code>）</li>
</ul>
</li>
</ul>
<h4 id="6、使用元类metaclass"><a href="#6、使用元类metaclass" class="headerlink" title="6、使用元类metaclass"></a>6、使用元类<code>metaclass</code></h4><ul>
<li><p><code>type()</code></p>
<ul>
<li><p>查看一个类型或变量的类型</p>
<p><code>Hello</code>是一个class，它的类型就是<code>type`</code></p>
<p><code>h = Hello()</code>，<code>h</code>是一个实例，它的类型就是class<code>Hello</code></p>
</li>
<li><p>动态创建新的类型</p>
<p><code>Hello = type(&#39;Hello&#39;,(object,),dict(hello=fn))</code> #创建Hello class</p>
<p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p>
<ul>
<li>1、class的名称                       #<code>Hello</code></li>
<li>2、继承的父类==集合==，继承多重继承，==注意tuple的单元素写法 3==     #<code>(object,)</code></li>
<li>3、class的方法与函数绑定         #<code>decit(hello=fn)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>metaclass</code>：控制类的创建行为</p>
<ul>
<li><p>1、先定义<code>metaclass</code></p>
<p><code>class ListMetaclass(type):</code></p>
<p>metaclass的类名以Metaclass结尾</p>
<p>==metaclass是类的模板，所以必须从type类型派生==</p>
</li>
<li><p>2、再创建<code>class</code></p>
<p><code>class MyList(list,metaclass=ListMetaclass:</code></p>
<p>==定义类时，需要传入关键字metaclass==</p>
</li>
<li><p>3、最后创建实例</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数部分</title>
    <url>/2019/10/20/python%E7%AC%94%E8%AE%B02(%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="一、-函数"><a href="#一、-函数" class="headerlink" title="一、 函数"></a>一、 函数</h3><p>在交互式命令行通过<code>help(函数名)</code>查看函数的帮助信息</p>
<h4 id="1-基本函数"><a href="#1-基本函数" class="headerlink" title="1 基本函数"></a>1 基本函数</h4><ul>
<li><p><strong><code>print()</code>函数</strong></p>
<p><code>print()</code></p>
<p>print会依次打印每个字符串，遇到逗号“，”会输出一个空格,print自动换行</p>
</li>
<li><p><strong><code>input()</code>函数</strong></p>
<p><code>input()</code>，input输入的是<code>str</code>类型的</p>
<p><code>a = input(&#39;name:&#39;)</code>会输出提示信息</p>
</li>
<li><p><strong><code>int()</code>函数</strong></p>
<p>数据类型转换，将str转换为整数</p>
<p>例：<code>b = int(s)</code></p>
</li>
<li><p><strong><code>abs</code>函数</strong></p>
<p>求绝对值</p>
</li>
<li><p><strong><code>max()</code>函数</strong></p>
<p>可以接收任意多个参数，并返回最大的</p>
</li>
<li><p><strong><code>hex()</code>函数</strong></p>
<p>把一个整数转换成十六进制表示的字符串</p>
</li>
<li><p><strong><code>range()</code>函数</strong></p>
<p>可以生成一个整数序列，从0开始生产</p>
<p><code>list()</code>函数可以转换为list</p>
<p><code>print(list(range(5)))</code></p>
</li>
<li><p><strong><code>isinstance</code>函数</strong></p>
<p>可以判断一个变量是不是字符串</p>
<p><code>isinstance(x, str)</code></p>
</li>
<li><p><strong><code>sum函数</code></strong></p>
<p>可以直接求和</p>
</li>
</ul>
<h4 id="2-定义函数"><a href="#2-定义函数" class="headerlink" title="2 定义函数"></a>2 定义函数</h4><ol>
<li><p>使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code></p>
</li>
<li><p>在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回</p>
<p>例<code>def my_abs(x):</code></p>
</li>
</ol>
<h5 id="（1）定义一个空函数："><a href="#（1）定义一个空函数：" class="headerlink" title="（1）定义一个空函数："></a>（1）定义一个空函数：</h5><p><strong>用<code>pass</code>语句</strong></p>
<p>例：<code>def nop():</code><br>      <code>pass</code></p>
<h5 id="（2）函数的参数"><a href="#（2）函数的参数" class="headerlink" title="（2）函数的参数"></a>（2）函数的参数</h5><p><strong>1.位置参数：</strong></p>
<ul>
<li><p>调用函数时，传入的两个值按照位置顺序依次赋给参数</p>
<p>例：<code>def power(x):</code></p>
</li>
</ul>
<p><strong>2.默认参数：</strong></p>
<ul>
<li><p>必选参数在前，默认参数在后</p>
</li>
<li><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数</p>
</li>
<li><p>可以按顺序提供默认参数</p>
</li>
<li><p>可以不按顺序提供部分默认参数，但需将参数名加上</p>
<p>==默认参数必须指向不变对象==</p>
<p>例：<code>def enroll(name, gender, age=6, city=&#39;Beijing&#39;):</code></p>
</li>
</ul>
<p><strong>3.可变参数：</strong></p>
<ul>
<li><p><code>*args</code>是可变参数，args接收的是一个tuple</p>
</li>
<li><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去</p>
</li>
<li><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个==tuple==</p>
</li>
<li><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code></p>
<p>例：<code>def calc(*numbers):</code></p>
</li>
</ul>
<p><strong>4.关键字参数：</strong></p>
<ul>
<li><p><code>**kw</code>是关键字参数，kw接收的是一个dict</p>
</li>
<li><p>关键字参数==允许传入==0个或任意个==含参数名的参数==，这些关键字参数在函数内部自动组装为一个==dict==</p>
</li>
<li><p>可以==扩展函数的功能==</p>
</li>
<li><p>函数的调用者可以传入任意==不受限制的关键字参数==</p>
</li>
<li><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p>
<p>例：<code>def person(name, age, **kw):</code></p>
</li>
</ul>
<p><strong>5.命名关键字参数</strong></p>
<ul>
<li>命名的关键字参数是为了限制关键字参数，同时可以提供默认值（可以有缺省值）。</li>
<li><code>*</code>后面的是命名关键字参数，如果已经有了可变参数，就不需要再加一个<code>*</code></li>
<li>命名关键字必须==传入参数名==</li>
<li>==每一个命名关键字参数都必须有值==</li>
<li><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>
<p><strong>6.参数组合</strong></p>
</li>
<li><p>参数定义的顺序必须是：位置参数、默认参数、可变参数(<code>*</code>)、命名关键字参数(<code>*</code>)和关键字参数(<code>**</code>)</p>
</li>
</ul>
<h5 id="（3）参数检查"><a href="#（3）参数检查" class="headerlink" title="（3）参数检查"></a>（3）参数检查</h5><p>数据类型检查可以用内置函数<code>isinstance()</code>实现</p>
<p><code>if not isinstance(x, (int, float)):</code><br>    <code>raise TypeError(&#39;bad operand type&#39;)</code></p>
<h5 id="（4）返回多个值（返回tuple）"><a href="#（4）返回多个值（返回tuple）" class="headerlink" title="（4）返回多个值（返回tuple）"></a>（4）返回多个值（返回tuple）</h5><p>Python的函数返回多值其实就是返回一个tuple</p>
<p>返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值</p>
<h3 id="二、高级特性"><a href="#二、高级特性" class="headerlink" title="二、高级特性"></a>二、高级特性</h3><hr>
<h4 id="1、切片"><a href="#1、切片" class="headerlink" title="1、切片"></a>1、切片</h4><p><code>L[起始索引:结束索引:间隔大小]</code>，若第一个索引为0，可省略；若间隔大小为1，可省略；可以全部省略，则为复制</p>
<p><code>L[0:3]</code>：0 &lt;= L &lt; 3    (不包含3)</p>
<p>可对list、tuple、字符串进行切片,灵活</p>
<p>支持倒数切片</p>
<h4 id="2、迭代Iteration"><a href="#2、迭代Iteration" class="headerlink" title="2、迭代Iteration"></a>2、迭代<code>Iteration</code></h4><p><code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration)</p>
<p>在Python中，迭代是通过<code>for ... in</code>来完成的</p>
<p>dict的储存不是按照list的方式顺序排列的，迭代出的结果顺序可能不一样</p>
<p><strong>dict迭代：</strong></p>
<ul>
<li>默认情况下，dict迭代的是key</li>
<li>如果要迭代value，可以用<code>for value in d.values()</code></li>
<li>如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</li>
</ul>
<p><strong>如何判断一个对象是可迭代对象呢？</strong></p>
<p>方法是通过collections模块的Iterable类型判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable)</span><br></pre></td></tr></table></figure>
<p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">    print(i, value)</span><br></pre></td></tr></table></figure>
<p>任何可迭代对象都可以作用于<code>for</code>循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用<code>for</code>循环</p>
<h4 id="3、列表生成式"><a href="#3、列表生成式" class="headerlink" title="3、列表生成式"></a>3、列表生成式</h4><p>用来创建list的生成式</p>
<p>for循环创建list的生成式</p>
<p><code>[x * x for x in range(1, 11)]</code></p>
<h4 id="4、生成器generator"><a href="#4、生成器generator" class="headerlink" title="4、生成器generator"></a>4、生成器<code>generator</code></h4><p>这种一边循环一边计算的机制，称为生成器：generator</p>
<ul>
<li>创建一个generator<ul>
<li>1、方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code></li>
<li>2、函数定义中包含<code>yield</code>关键字，那么这个函数是一个generator</li>
</ul>
</li>
</ul>
<p>generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行</p>
<ul>
<li><p>调用</p>
<p>调用generator时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值</p>
</li>
<li><p>返回值</p>
<p>用<code>for</code>循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p>
</li>
<li><p>结束</p>
<p>对于函数改成的generator来说，遇到<code>return</code>语句或者执行到函数体最后一行语句，就是结束generator的指令，<code>for</code>循环随之结束。</p>
</li>
</ul>
<h4 id="5、迭代器Iterator"><a href="#5、迭代器Iterator" class="headerlink" title="5、迭代器Iterator"></a>5、迭代器<code>Iterator</code></h4><ul>
<li><p>可以直接作用于for循环的数据类型有：</p>
<ul>
<li>list、tuple、dict、set、str</li>
<li>generator（包括生成器和带yield的函数）</li>
</ul>
</li>
<li><p>可以直接作用于<code>for</code>循环的对象统称为==可迭代对象==：<code>Iterable</code></p>
<ul>
<li><p><code>可以使用</code>isinstance()<code>判断一个对象是否是Iterable对象</code></p>
</li>
<li><p>from collections import Iterable</p>
<p>例：</p>
<p><code>from collections import Iterable</code></p>
<p><code>isinstance([], Iterable)</code></p>
</li>
<li></li>
</ul>
</li>
<li><p>被<code>next()</code>函数调用并不断返回下一个值的对象称为==迭代器==：<code>Iterator</code></p>
<ul>
<li><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象</p>
<p>例：</p>
<p><code>from collections import Iterator</code></p>
<p><code>isinstance((x for x in range(10)), Iterator)</code></p>
</li>
</ul>
</li>
<li><p>使用<code>iter()</code>把<code>list、dict、str</code>等<code>Iterable</code>变成<code>Iterator</code></p>
</li>
</ul>
<h3 id="三、函数式编程"><a href="#三、函数式编程" class="headerlink" title="三、函数式编程"></a>三、函数式编程</h3><hr>
<h4 id="1、高阶函数"><a href="#1、高阶函数" class="headerlink" title="1、高阶函数"></a>1、高阶函数</h4><p>函数就是面向过程的程序设计的基本单元</p>
<p>函数本身也可以赋值给变量，即：变量可以指向函数</p>
<p>==函数名其实就是指向函数的变量==</p>
<p>高阶函数：一个函数就可以接收另一个函数作为参数</p>
<ul>
<li><p>map/reduce</p>
<ul>
<li><p>map（两个参数）</p>
<p>map函数接受两个参数，一个函数，一个是<code>Iterable</code>，map==将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterable</code>放回==</p>
<p><code>Iterator</code>是惰性序列，通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list</p>
</li>
<li><p>reduce（两个参数）</p>
<p>把一个函数==作用在一个序列<code>[x1,x2,x3,x4......]</code>上==</p>
<p>这个函数必须接受两个参数，reduce把结果继续和下一个元素做累计计算</p>
<p><code>reduce(f,[x1,x2,x3,x4]) = f(f(f(x1,x2),x3),x4)</code></p>
</li>
</ul>
</li>
<li><p>filter：过滤序列（两个参数）</p>
<p>接收一个函数与一个序列，与map类似依次作用于每个元素，但==根据返回值确定是否丢弃元素==</p>
<p>返回值也是一个Iterator（惰性序列），需要list函数获取结果并返回list</p>
</li>
<li><p>sorted：排序算法（三个参数）</p>
<p>可以接收一个key函数来实现自定义的排序</p>
<p>例：<code>sorted([3,65,3,4],key=abs)</code></p>
<p>忽略大小写：</p>
<p><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)</code></p>
<p>进行反向排序，传入第三个参数<code>reverse=True</code></p>
<p><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)</code></p>
</li>
</ul>
<h4 id="2、返回函数"><a href="#2、返回函数" class="headerlink" title="2、返回函数"></a>2、返回函数</h4><p>相关参数和变量都保存在返回的函数中，称为“闭包”</p>
<p>==每次调用互不影响==</p>
<p>==返回的函数不会立刻执行==</p>
<p>==返回函数不要引用任何循环变量，或者后续会发生变化的变量==，如果使用的话，多次调用的结果会相同</p>
<h4 id="3、匿名函数（lambda）"><a href="#3、匿名函数（lambda）" class="headerlink" title="3、匿名函数（lambda）"></a>3、匿名函数（<code>lambda</code>）</h4><p>关键字<code>lambda</code>表示匿名函数，冒号前面的x表示函数参数</p>
<p><code>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</code></p>
<p>==匿名函数只能有一个表达式==，不用写return，返回值就是该表达式的结果</p>
<p>匿名函数不会冲突</p>
<p>匿名函数也是一个函数对象，可以把匿名函数赋值给一个变量，也可以吧匿名函数作为返回值返回</p>
<p><code>def build(x, y):
    return lambda: x * x + y * y</code></p>
<h4 id="4、装饰器（-）"><a href="#4、装饰器（-）" class="headerlink" title="4、装饰器（@）"></a>4、装饰器（<code>@</code>）</h4><p>在代码运行期间增加功能的方式，称为“装饰器”（Decorator）</p>
<p>函数有一个<code>__name__</code>可以拿到函数的名字</p>
<p><code>functools.wrap</code>&lt;==&gt;<code>wrapper.__name__ = func.__name__</code>（交换函数签名）</p>
<p>一个完整的decorator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">	@functools.warps(func)</span><br></pre></td></tr></table></figure>
<h4 id="5、偏函数（functools-partial）"><a href="#5、偏函数（functools-partial）" class="headerlink" title="5、偏函数（functools.partial）"></a>5、偏函数（<code>functools.partial</code>）</h4><p>偏函数（Partial function）：把一个函数的某些参数固定</p>
<p><code>functools.partial</code>创建一个偏函数，给一个函数设定默认参数（在函数调用的时候也可以传入其他值），返回一个新函数</p>
<p><code>int2 = functools.paratial(int,base=2)</code></p>
<p>创建偏函数的时候，可以接收<code>函数对象</code>、<code>*args</code>、<code>**kw</code></p>
<h3 id="四、-模块"><a href="#四、-模块" class="headerlink" title="四、 模块"></a>四、 模块</h3><hr>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li><p>公开（public）：正常的函数和变量名，可以被直接引用</p>
</li>
<li><p>特殊变量：<code>__xxx__</code>，定义自己的变量一般不用</p>
</li>
<li>私有（private）：<code>_xxx</code>和<code>__xxx</code>，不应该直接引用private函数</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础部分</title>
    <url>/2019/10/20/python%E7%AC%94%E8%AE%B01(%E5%9F%BA%E7%A1%80)/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="Python笔记"><a href="#Python笔记" class="headerlink" title="Python笔记"></a>Python笔记</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解释型的语言，则必须把源码发布出去</span><br><span class="line"></span><br><span class="line">代码少的代价是运行速度慢</span><br><span class="line"></span><br><span class="line">C语言适合开发那些追求运行速度、充分发挥硬件性能的程序</span><br><span class="line"></span><br><span class="line">解释器或者编译器就是负责把符合语法的程序代码转化为CPU能够与执行的机器码，然后执行。</span><br><span class="line"></span><br><span class="line">变量本身类型不确定的语言变量是`动态语言`，静态语言在定义变量时必须制定变量类型</span><br></pre></td></tr></table></figure>
<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>Python之父Guido van Rossum（荷兰）龟叔</p>
<p>代码少的代价是运行速度慢</p>
<p>C语言适合开发那些追求运行速度、充分发挥硬件性能的程序，而Python是用来编写应用程序的高级编程语言。</p>
<p>Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池”;除了内置的库外，Python还有大量的第三方库</p>
<ul>
<li>应用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首选是网络应用，包括网站、后台服务等等；</span><br><span class="line"></span><br><span class="line">其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</span><br><span class="line"></span><br><span class="line">另外就是把其他语言开发的程序再包装起来，方便使用。</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个缺点就是运行速度慢。Python是解释型语言，代码在执行时会一行一行地翻译成CPU能理解的机器码。</span><br><span class="line">第二个缺点就是代码不能加密。解释型的语言，则必须把源码发布出去。</span><br></pre></td></tr></table></figure>
<p>退出python交互模式：<code>exit()</code>或者<code>ctrl+z</code></p>
<p>Python交互模式的代码是输入一行，执行一行，而命令行模式下直接运行<code>.py</code>文件是一次性执行该文件内的所有代码</p>
<h3 id="二、简单的数据类型和变量"><a href="#二、简单的数据类型和变量" class="headerlink" title="二、简单的数据类型和变量"></a>二、简单的数据类型和变量</h3><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在Python中严格区分大小写</span><br><span class="line">2.Python中的每一行就是一条语句，每条语句以换行结束</span><br><span class="line">3.Python中每一行语句不要过长（规范中建议每行不要超过80个字符）</span><br><span class="line">4.一条语句可以分多行编写，多行编写时语句后边以\结尾  </span><br><span class="line">5.Python是缩进严格的语言，所以在Python中不要随便写缩进  </span><br><span class="line">6.在Python中使用#来表示注释，#后的内容都属于注释，注释的内容将会被解释器所忽略</span><br><span class="line">    我们可以通过注释来对程序进行解释说明，一定要养成良好的编写注释的习惯</span><br><span class="line">    注释要求简单明了，一般习惯上#后边会跟着一个空格</span><br></pre></td></tr></table></figure>
<h4 id="2-编码问题"><a href="#2-编码问题" class="headerlink" title="2. 编码问题"></a>2. 编码问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unicode将所有语言都统一到一套编码里</span><br><span class="line"></span><br><span class="line">ASCII码是一个字节，Unicode编码通常是两个字节</span><br><span class="line"></span><br><span class="line">把Unicode编码转化为“可变长编码”的UTF-8编码，常用英文字母是一个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</span><br><span class="line"></span><br><span class="line">ASCII编码可以看成UTF-8编码的一部分</span><br><span class="line"></span><br><span class="line">计算机内存中，统一使用Unicode编码，在需要保存到硬盘或者传输的时候，就转化为UTF-8编码</span><br></pre></td></tr></table></figure>
<p>==ASCII码的范围是：0-255或-128-+127==</p>
<p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，，中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code></p>
<p>==中文的编码超过了ASCII的编码范围，好像是句废话==</p>
<h4 id="3-变量命名"><a href="#3-变量命名" class="headerlink" title="3.变量命名"></a>3.变量命名</h4><ol>
<li>标识符中可以含有字母、数字、_，但是不能使用数字开头</li>
<li>标识符不能是Python中的关键字和保留字，不使用Python中的函数名作为标识符</li>
<li>命名规范：</li>
</ol>
<ul>
<li><p>在Python中注意遵循两种命名规范：</p>
<ul>
<li><p>下划线命名法</p>
<p>所有字母小写，单词之间使用_分割</p>
</li>
<li><p>帕斯卡命名法（大驼峰命名法）  </p>
<p>首字母大写，每个单词开头字母大写，其余字母小写</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h4><ol>
<li>以<code>#</code>号开头，注释掉一行代码</li>
<li>以<code>&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;</code>三对引号，注释掉多行代码</li>
<li>中文注释<code>#coding = utf-8</code></li>
</ol>
<p>python区分大小写，使用缩进来组织代码块（4个缩进）</p>
<p>==Python的基本数据类型：数字、字符串、列表、字典、元组==</p>
<h4 id="5-简单数据类型和变量"><a href="#5-简单数据类型和变量" class="headerlink" title="5. 简单数据类型和变量"></a>5. 简单数据类型和变量</h4><h5 id="1、数值："><a href="#1、数值：" class="headerlink" title="1、数值："></a>1、数值：</h5><ol>
<li><p>整数</p>
<p>Python的整数没有大小限制</p>
<p>如果数字的长度过大，可以使用下划线作为分隔符</p>
</li>
<li><p>浮点数（用e表示10,如：1.23e9）</p>
<p>Python中所有的小数都是float类型，没有大小限制，但超出一定范围就直接表示为<code>inf</code>（无限大）</p>
</li>
<li><p>复数</p>
</li>
</ol>
<h5 id="2、字符串-在Python-3中，是以Unicode编码的"><a href="#2、字符串-在Python-3中，是以Unicode编码的" class="headerlink" title="2、字符串(在Python 3中，是以Unicode编码的)"></a>2、字符串(在Python 3中，是以Unicode编码的)</h5><ul>
<li><p>以单引号或者双引号括起来的内容</p>
</li>
<li><p><code>ord()</code>函数：获取字符的整数表示</p>
</li>
<li><p><code>chr()</code>函数：把编码转换成对应的字符</p>
</li>
<li><p>转义字符\，python内部允许使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内的字符串默认不转义</p>
</li>
<li><p>允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p>
</li>
<li><p>输出格式化字符串</p>
<ul>
<li><p>与c语言相同，用%引导</p>
<p>例：<code>print(&#39;Hi,%s have %d&#39; %(&#39;you&#39;,1000))</code></p>
<p>%s会把任意数据类型转化为字符串</p>
<p><code>%%</code>表示一个%</p>
</li>
<li><p><code>format()</code>函数</p>
<p>它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……==需要从0开始==</p>
<p>例：<code>print(&#39;{0} and {1}&#39;.format(12,21))</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、布尔值（ture和false）"><a href="#3、布尔值（ture和false）" class="headerlink" title="3、布尔值（ture和false）"></a>3、布尔值（<code>ture</code>和<code>false</code>）</h5><p>布尔值可以用<code>and</code> （与运算）<code>or</code>（或运算） <code>not</code>（非运算） 运算    </p>
<h5 id="4、空值"><a href="#4、空值" class="headerlink" title="4、空值"></a>4、空值</h5><p>空值用None表示</p>
<h5 id="5、变量"><a href="#5、变量" class="headerlink" title="5、变量"></a>5、变量</h5><p>变量名必须是数字、英文和下划<code>_</code>线的组合，不能用数字开头</p>
<h5 id="6、常量"><a href="#6、常量" class="headerlink" title="6、常量"></a>6、常量</h5><p>通常用大写的变量名表示常量（实际仍是变量）</p>
<h5 id="7、bytes"><a href="#7、bytes" class="headerlink" title="7、bytes"></a>7、bytes</h5><p>如果需要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>转换为以字节为单位的<code>bytes</code>。</p>
<p>在网上或磁盘上读取数字流，读到的数据是<code>bytes</code>。</p>
<p>==bytes的每个字符都只占一个字节。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表示：b&apos;&apos;</span><br><span class="line">例:x = b&apos;abc&apos;</span><br></pre></td></tr></table></figure>
<p><strong>(1) 将<code>str</code>转化为<code>bytes</code></strong></p>
<p>以Unicode表示的<code>str</code>通过<code>encode()</code>可以编码为指定的<code>bytes</code></p>
<p>例：<code>&#39;abc&#39;.encode(&#39;ascii&#39;)</code></p>
<p><strong>(2) 将<code>bytes</code>转化为<code>str</code></strong></p>
<p>通过<code>decode()</code>方法</p>
<p>例：<code>b&#39;abc&#39;.decode(&#39;ascii&#39;)</code></p>
<p>若<code>bytes</code>中包含无法解码的字节，<code>decode()</code>会报错，若<code>bytes</code>中只有一小部分无效，可以传入    <code>errors=&#39;ignore&#39;</code>忽略错误的字节</p>
<p><strong>计算字符数的长度</strong></p>
<p><code>len()</code>函数，==<code>str</code>计算的是字节数，<code>bytes</code>计算的是字节数==</p>
<p>例：<code>len(&#39;abc&#39;)</code> <code>len(b&#39;abc&#39;)</code></p>
<p>==在保存源代码时，保存为UTF-8编码==</p>
<p>取源代码时，为了让它按UTF-8编码读取，通常在文件开头加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3  //告诉Linux/OS X系统，这是一个Python可执行程序</span><br><span class="line">#-*- coding: utf-8 -*-	//告诉python解释器，按照UTF-8编码读取源代码</span><br><span class="line">保存时也需保存为UTF-8编码</span><br></pre></td></tr></table></figure>
<h3 id="三、序列"><a href="#三、序列" class="headerlink" title="三、序列"></a>三、序列</h3><p><strong>list和tuple（内置的有序集合）</strong></p>
<h4 id="1-列表：list"><a href="#1-列表：list" class="headerlink" title="1. 列表：list:[]"></a>1. 列表：list:<code>[]</code></h4><p><strong>有序列表（像数组与结构体的结合）</strong></p>
<p>内置的一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素</p>
<p>列表里面的数据类型可以不同，也可以含有列表（看成多维数组）</p>
<p><strong>操作：</strong></p>
<ul>
<li><p>增：</p>
<p><code>a.append(elem)</code>加到末尾</p>
<p><code>a.insert(site,elem)</code>添加到指定位置</p>
</li>
<li><p>删：</p>
<p><code>a.pop(site)</code>不加位置，默认末尾</p>
</li>
<li><p>改：</p>
<p>赋值给对应的索位置</p>
</li>
<li><p>查：</p>
<p>索引与数组相同是从0开始</p>
<p><code>a[site]</code>,查看site处元素，==site可以为-1，即查询最后一个元素==</p>
</li>
</ul>
<h4 id="2-元组-tuple"><a href="#2-元组-tuple" class="headerlink" title="2. 元组: tuple:()"></a>2. 元组: tuple:<code>()</code></h4><p><strong>（有序列表）</strong></p>
<p>==tuple一旦初始化就不能更改==，查询与<code>list</code>相同</p>
<ul>
<li><p>只有一个元素的tuple</p>
<p>==定义时必须加一个逗号<code>,</code>==以消除歧义<code>a = (1,)</code></p>
<p>若<code>a = (1)</code>定义的是<code>1</code>这个数</p>
</li>
<li><p>“可变的”tuple（实际是list在变）：</p>
<p>tuple中包含list：a = tuple(‘a’,’b’,[‘A’,’B’])<code>tuple包含三个元素，</code>a，b和list</p>
</li>
</ul>
<h3 id="四、字典-dic"><a href="#四、字典-dic" class="headerlink" title="四、字典 dic:{}"></a>四、字典 dic:<code>{}</code></h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ol>
<li>字典是一种可变的容器，可以存储任意类型的数据</li>
<li>字典中每个数据都是用‘键’（key）进行索引，而不像序列可以用下标进行索引</li>
<li>字典的数据没有先后顺序关系，字典的存储是==无序==的</li>
<li>字典中的数据以键（key）-值（value）队进行映射存储,查找速度快</li>
<li>字典的键不能重复，且只能用==不可变类型==作为字典的键。</li>
</ol>
<p>表示方法：<code>用{}括起来，以冒号（：）分割键-值对，各键值对用分号分隔开</code></p>
<p>例：<code>d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}</code></p>
<h4 id="2-创建"><a href="#2-创建" class="headerlink" title="2. 创建"></a>2. 创建</h4><p><strong>（1）创建空字典：  </strong></p>
<ul>
<li><code>d = {}</code></li>
</ul>
<p><strong>（2）创建非空字典：</strong></p>
<ul>
<li><code>d = {&#39;name&#39;:&#39;tarena&#39;,&#39;age&#39;:&#39;15&#39;}</code></li>
</ul>
<p><strong>（3）字典的构造函数 dict：</strong></p>
<ul>
<li>dict（）  创建一个空字典，等同于{}</li>
<li>dict（iterable）  用可迭代对象初始化一个字典</li>
<li>dict（**kwargs）  关键字传参形式生成一个字典</li>
</ul>
<h4 id="3-增"><a href="#3-增" class="headerlink" title="3. 增"></a>3. 增</h4><p>即把数据放入dict的方法：</p>
<ul>
<li><p>（1）除了初始化时指定外</p>
</li>
<li><p>（2）通过key放入</p>
<p><code>d[&#39;Adam&#39;] = 67</code></p>
</li>
</ul>
<p>一个key只能对应一个value</p>
<h4 id="4-删"><a href="#4-删" class="headerlink" title="4. 删"></a>4. 删</h4><p><strong>删除一个key：</strong></p>
<ul>
<li>用<code>pop(key)</code>方法，对应的value也会从dict中删除</li>
</ul>
<h4 id="5-要避免key不存在的错误"><a href="#5-要避免key不存在的错误" class="headerlink" title="5. 要避免key不存在的错误:"></a>5. 要避免key不存在的错误:</h4><ul>
<li><p>(1)通过<code>in/not in</code>判断key是否存在：</p>
<p><code>&#39;Thomas&#39; in d</code>     #如果存在返回True，否则返回False；not in 与in返回值相反</p>
</li>
<li><p>(2)通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<p><code>d.get(&#39;Thomas&#39;, -1)</code></p>
</li>
</ul>
<p>==dict的key必须是<strong>不可变对象</strong>==</p>
<p>通过key计算位置的算法称为哈希算法（Hash）</p>
<h3 id="五、集合set"><a href="#五、集合set" class="headerlink" title="五、集合set"></a>五、集合set</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1. 特点"></a>1. 特点</h4><ol>
<li>集合是可变的容器</li>
<li>集合内的数据对象是唯一的，即没有重复的key，==重复元素在set中自动被过滤==</li>
<li>集合是无序的存储结构，集合中的数据没有先后关系</li>
<li>set的原理和dict一样，集合内的元素必须是==不可变对象==</li>
<li>集合是可迭代的</li>
<li>集合是相当于只有键没有值的字典（是一组key的集合，但不存储value）</li>
</ol>
<p>==对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容这些方法会创建新的对象并返回==</p>
<h4 id="2-创建-1"><a href="#2-创建-1" class="headerlink" title="2. 创建"></a>2. 创建</h4><p>要创建一个set，需要提供一个list作为输入集合</p>
<p>  <strong>（1）创建空的集合：</strong><br>      <code>set（）   #set（）创建一个空的集合</code></p>
<p><strong>（2）创建非空集合：</strong><br>      <code>s = {1,2,3}  #集合中的三个整数1,2,3</code><br><strong>（3）集合的构造函数 set：</strong></p>
<ul>
<li>set（）创建空集合</li>
<li>set（iterable）  用可迭代对象创建一个新的集合对象  </li>
</ul>
<h4 id="3-增-1"><a href="#3-增-1" class="headerlink" title="3. 增"></a>3. 增</h4><ul>
<li>通过<code>add(key)</code>方法</li>
<li><code>s.add(4)</code></li>
</ul>
<h4 id="4-删-1"><a href="#4-删-1" class="headerlink" title="4. 删"></a>4. 删</h4><ul>
<li>通过<code>remove(key)</code>方法</li>
<li><code>s.remove(4)</code></li>
</ul>
<h4 id="5-数学意义上的交集、并集等操作"><a href="#5-数学意义上的交集、并集等操作" class="headerlink" title="5. 数学意义上的交集、并集等操作"></a>5. 数学意义上的交集、并集等操作</h4><ul>
<li>交集：<code>s1 &amp; s2</code></li>
<li>并集：<code>s1 | s2</code></li>
</ul>
<h3 id="五、判断"><a href="#五、判断" class="headerlink" title="五、判断"></a>五、判断</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><ul>
<li><p>python的if没有括号，==依靠缩进==</p>
</li>
<li><p><code>if</code>与<code>else</code>后有冒号<code>:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line"></span><br><span class="line">else：</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>elif</code>：（else if）</p>
</li>
</ul>
<h3 id="六、循环"><a href="#六、循环" class="headerlink" title="六、循环"></a>六、循环</h3><ol>
<li>for…in循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in ...:  #把每个元素带入变量x，然后执行缩进语句</span><br><span class="line">	print(x)</span><br></pre></td></tr></table></figure>
<p><code>[x * x for x in range(1, 11)]</code></p>
<p>for循环后面加上if判断：<code>[x * x for x in range(1, 11) if x % 2 == 0]</code></p>
<p>两层循环：<code>[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code></p>
<p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value</p>
<p><code>for k, v in d.items():
     print(k, &#39;=&#39;, v)</code></p>
<h4 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2. while循环"></a>2. while循环</h4><p>与C语言同</p>
<h4 id="3-退出循环"><a href="#3-退出循环" class="headerlink" title="3. 退出循环"></a>3. 退出循环</h4><ul>
<li>break：退出循环</li>
<li>continue：退出当前循环</li>
</ul>
<h3 id="七、运算"><a href="#七、运算" class="headerlink" title="七、运算"></a>七、运算</h3><h4 id="1-除法"><a href="#1-除法" class="headerlink" title="1. 除法"></a>1. 除法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10/3	#除法结果是浮点数</span><br><span class="line">10//3	#除法结果是整数</span><br><span class="line">10%3	#取余运算，结果是整数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell基本指令</title>
    <url>/2019/04/14/Shell%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Shell基本指令"><a href="#Shell基本指令" class="headerlink" title="Shell基本指令"></a>Shell基本指令</h3><p>[TOC]</p>
<ul>
<li>“-“：引导短格式选项（单个字符）如：-l</li>
<li>多个短格式选项可以写在一起，用一个”-“引导 如：-al</li>
<li>“–”：引导长格式选项（多个字符）如：–color</li>
</ul>
<h4 id="一、辅助快捷键"><a href="#一、辅助快捷键" class="headerlink" title="一、辅助快捷键"></a>一、辅助快捷键</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tab：自动补齐</span><br><span class="line">&quot; \ &quot;	 ：强制换行</span><br><span class="line">Ctrl + u ：清空至行首</span><br><span class="line">Ctrl + k ：清空至行尾</span><br><span class="line">Ctrl +ｃ ：终止命令执行</span><br></pre></td></tr></table></figure>
<h4 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h4><p>1、top命令：查看系统cpu、内存等使用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：top</span><br></pre></td></tr></table></figure>
<p>2、date命令：系统日期设定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：date　		显示当前日期时间</span><br><span class="line">	date -s time   设置系统时间</span><br></pre></td></tr></table></figure>
<p>3、cpu信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/proc/cpuinfo</span><br><span class="line">例：cat /proc/cpuinfo 	   查看cpu信息</span><br><span class="line">    cat /proc/meminfo 		查看内存信息</span><br></pre></td></tr></table></figure>
<p>4、history：查看历史命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure>
<p>5、关机及重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-  关机操作：</span><br><span class="line">		shutdow -h now（h：halt）</span><br><span class="line">		poweroff</span><br><span class="line">		halt</span><br><span class="line">-  重启操作：</span><br><span class="line">		shoutdown -r now（r：reboot）</span><br><span class="line">		reboot</span><br></pre></td></tr></table></figure>
<p>6、man命令：查看某个命令的帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：man 命令</span><br><span class="line">例：man ls</span><br></pre></td></tr></table></figure>
<p>7、ps命令：显示进程信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps ux 		显示当前用户的进程</span><br><span class="line">ps uxwww 	显示当前用户的进程的详细信息</span><br><span class="line">ps aux 		显示所有用户的进程</span><br><span class="line">ps ef 		显示系统所有进程信息</span><br></pre></td></tr></table></figure>
<p>8、kill命令：干掉某个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 1001　		将进程编号为1001的程序干掉</span><br><span class="line">kill all -9 name　	将所有名字为name的程序杀死</span><br></pre></td></tr></table></figure>
<h4 id="三、用户命令"><a href="#三、用户命令" class="headerlink" title="三、用户命令"></a>三、用户命令</h4><p>1、uname：（ Unix name）查看系统相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：uname [选项]</span><br><span class="line">命令选项：</span><br><span class="line">		-a   （all）显示主机名、内核版本等信息</span><br><span class="line">		-r：（root）显示内核版本</span><br><span class="line">例：uname -r</span><br></pre></td></tr></table></figure>
<p>2、hostname：查看系统主机名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：hostname （Windows通用）</span><br></pre></td></tr></table></figure>
<p>3、useradd：添加用户账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：useradd [参数] 用户名</span><br><span class="line">参数：</span><br><span class="line">	-u：指定UID标记号</span><br><span class="line">	-d：指定宿主目录，缺省为/home/用户名</span><br><span class="line">	-e：指定账户失效时间</span><br><span class="line">	-g：指定用户的基本组名（或UID号（UserID））</span><br><span class="line">	-G：指定用户的附加组名（或GID号（Group ID））</span><br><span class="line">	-M：不为用户建立并初始化宿主目录</span><br><span class="line">	-s：指定用户登录的shell</span><br><span class="line">例：useradd </span><br><span class="line">切换用户：su 用户名</span><br><span class="line">设置密码：passwd 用户名</span><br></pre></td></tr></table></figure>
<p>4、userdel：删除用户账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：userdel [参数] 用户名</span><br><span class="line">	-r：连同用户的宿主目录一并删除</span><br></pre></td></tr></table></figure>
<p>5、w命令：显示登录用户的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: w</span><br></pre></td></tr></table></figure>
<p>6、last命令：查看最近那些用户登录系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：last</span><br></pre></td></tr></table></figure>
<p>7、su命令：切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：su - 		切换到超级用户</span><br></pre></td></tr></table></figure>
<p>8、groupadd命令：添加组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：groupadd usename  </span><br><span class="line">例：group asd  	添加asd组</span><br></pre></td></tr></table></figure>
<p>9、passwd命令：更改用户密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd username　	修改用户的密码</span><br><span class="line">passwd -d username　 将用户的密码删除</span><br></pre></td></tr></table></figure>
<p>10、chgrp命令：改变文件或目录的所有组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp username /dir　将/dir目录设置为username所有</span><br></pre></td></tr></table></figure>
<p>11、chmod命令：改变用户的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x file　将file文件设置为可执行</span><br><span class="line">chmod xxx file　设置file文件权限</span><br><span class="line">	注：rwxrwxrwx:对应421 421 421</span><br><span class="line">	   如：全部权限为777（需要什么权限就将对应的数值加起来）</span><br></pre></td></tr></table></figure>
<p>12、id命令：显示用户的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：id username</span><br><span class="line">例：id pcw</span><br></pre></td></tr></table></figure>
<h4 id="四、关于文件目录的命令"><a href="#四、关于文件目录的命令" class="headerlink" title="四、关于文件目录的命令"></a>四、关于文件目录的命令</h4><p>1、cd：（Change Directory）切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：cd [目录位置]</span><br><span class="line">例：cd /bin</span><br></pre></td></tr></table></figure>
<p>2、pwd：（print work directory）查看工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>2、ls：（list）列表显示目录内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ls [参数] [目录或文件名]</span><br><span class="line">参数：</span><br><span class="line">	 -l：（long）以长格式显示</span><br><span class="line">	 -a：（all）显示所有目录和文件（包含隐藏文件）的信息</span><br><span class="line">	 -A：与-a相似，但不显示&quot;.和&quot;..&quot;目录的信息</span><br><span class="line">	 -d：显示目录本身属性</span><br><span class="line">	 -h：以更易读的方式显示信息</span><br><span class="line">	 -R：（recursion）递归显示内容</span><br><span class="line">	 --color：以颜色区分不同类型文件</span><br><span class="line">例：ls -lh</span><br></pre></td></tr></table></figure>
<p>3、du：（Disk usage）统计目录及文件的空间占用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：du [参数] [目录或文件名]</span><br><span class="line">参数：</span><br><span class="line">		-a：（all）统计是包含所有文件</span><br><span class="line">		-h：以更易读的方式显示信息</span><br><span class="line">		-s：只统计每个参数所占空间总的大小</span><br><span class="line">例：du -sh /home（Disk usage）</span><br></pre></td></tr></table></figure>
<p>4、mkdir：（Make Directory）创建新的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：mkdir [-p] [路径] 目录名</span><br><span class="line">	-p：递归创建</span><br><span class="line">例：mkdir -p /asd/asd/asd</span><br></pre></td></tr></table></figure>
<p>5、touch：新建空文件、更新时间标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：touch 文件名</span><br><span class="line">	 //若该文件未创建则创建文件，若已创建则更新日期</span><br><span class="line">例：touch asd</span><br></pre></td></tr></table></figure>
<p>6、ln：（link）为文件或目录创建链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ln [-s] 源文件或目录 链接文件或目录</span><br><span class="line">		-s：（symbolic（符号的））建立符号链接文件，若省略此项则建立硬链接</span><br><span class="line">		//加s快捷方式，不加相当于复制了一份</span><br><span class="line">例：ln a asd</span><br></pre></td></tr></table></figure>
<p>7、cp：（copy）复制文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：cp [参数] 源文件或目录 目录文件或目录</span><br><span class="line">参数：</span><br><span class="line">		-r：（recursion）递归复制整个目录树</span><br><span class="line">		-p：保持源文件的属性不变</span><br><span class="line">		-f：（force）强制覆盖目标同名文件或目录</span><br><span class="line">		-i：（interactive）需要覆盖文件或目录时进行提醒</span><br><span class="line">例：cp -r /ss /asd</span><br></pre></td></tr></table></figure>
<p>8、rm：（remove）删除文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：rm [参数] 文件或目录</span><br><span class="line">参数：</span><br><span class="line">		-f：（force）强制删除文件或目录</span><br><span class="line">		-i：（interactive）删除文件或目录时提醒用户确认</span><br><span class="line">		-rf：递归强制删除</span><br><span class="line">		-r：（recursion）递归删除整个目录树</span><br><span class="line">例：rm -r /asd</span><br></pre></td></tr></table></figure>
<p>9、mv：（move）移动文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：mv [参数] 源文件或目录 目标文件或目录</span><br><span class="line">//若目标位置与源位置相同，则相当于改名</span><br><span class="line">参数：</span><br><span class="line">		-b ：（backup）若需覆盖文件，则覆盖前先行备份。 </span><br><span class="line">		-f ：（force）不询问而直接覆盖</span><br><span class="line">		-i ：（interactive）覆盖时会进行询问</span><br><span class="line">例：mv a c</span><br></pre></td></tr></table></figure>
<p>10、find：查找文件或目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：find [查找范围] [查找条件]</span><br><span class="line">常用查找条件：</span><br><span class="line">		-name：按文件名</span><br><span class="line">		-size：按文件大小</span><br><span class="line">		-user:：按文件属性</span><br><span class="line">		-type：按文件类型</span><br><span class="line">例：find /etc name  mas</span><br></pre></td></tr></table></figure>
<p>11、进入vi：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：vi [参数] [+[n]] [file]</span><br><span class="line">参数：</span><br><span class="line">		-r：（renew）用于恢复系统突然崩溃时正在编辑的文件</span><br><span class="line">		-R：（read only）用于以只读的方式打开文件</span><br><span class="line">		+n：（number）用来指明进入vi后直接位于文件的第n行，如果不指定，则位于最后一行</span><br><span class="line">例： vi +2 1</span><br></pre></td></tr></table></figure>
<p><strong>vi三种模式</strong>：<br>| 模式              | 进入方式          | 操作                |<br>| —————– | —————– | ——————- |<br>| 命令模式          | ESC进入           | dd：删除            |<br>|                   |                   | 2dd：删除两行       |<br>|                   |                   | D：从光标删除到行尾 |<br>|                   |                   | p：粘贴             |<br>|                   |                   | u：恢复，返回       |<br>|                   |                   | “.” : 重复前一命令  |<br>| 插入模式          | i：光标前插入     |                     |<br>|                   | a：光标下一个插入 |                     |<br>|                   | I：行首插入       |                     |<br>|                   | A：行尾插入       |                     |<br>|                   | o：下一行插入     |                     |<br>|                   | O：上一行插入     |                     |<br>| 底行模式          | shift+：进入      | q!：强制退出        |<br>|                   |                   | wq：保存退出        |<br>|                   | wc                | w：保存不退出       |<br>|                   |                   | set nu：显示行号    |<br>| ESC：回到命令模式 |                   |                     |</p>
<p><strong>搜索与替换：</strong></p>
<table>
<thead>
<tr>
<th>搜索</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>用n搜索下一个</td>
</tr>
<tr>
<td>例:</td>
<td>/asdf</td>
</tr>
<tr>
<td>?string</td>
<td>用n搜索下一个</td>
</tr>
<tr>
<td>例：</td>
<td>?asdf</td>
</tr>
</tbody>
</table>
<p>替换<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全文替换：%s/old/new/[c,g,i]</span><br><span class="line">例：%s/asd/zzz/g</span><br><span class="line">//%s:全文搜索</span><br><span class="line">部分替换：:n1,n2s/old /new/[c,g,i]</span><br><span class="line">例：2,3s/asd/zzz/g</span><br><span class="line">//n1:从n1开始,到n2结束</span><br><span class="line">//s：搜索</span><br><span class="line">参数：</span><br><span class="line">	c （confirm）每次替换前会询问</span><br><span class="line">	g （globe）不询问，整行替换</span><br><span class="line">	i （ignore） 不分大小写</span><br><span class="line">	I （ignore） 大小写敏感</span><br></pre></td></tr></table></figure></p>
<p>12、cat：（Concatenate 串联）显示文件的全部内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1：一次显示整个文件</span><br><span class="line">	 cat   文件名</span><br><span class="line">  例：cat /etc/passwd</span><br><span class="line">2：从键盘创建一个文件</span><br><span class="line">	cat  &gt;  文件名</span><br><span class="line">  例：cat &gt; 1</span><br><span class="line">//只能创建新文件,不能编辑已有文件，ctrl+d退出.</span><br><span class="line">3：将几个文件合并为一个文件</span><br><span class="line">	cat   文件1   文件2  &gt; 文件名</span><br><span class="line">  例：cat 1 2 &gt; 3</span><br></pre></td></tr></table></figure></p>
<p>13、wc：（word count）统计文件中的单词数量、字节数、行数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：wc [参数] 文件名</span><br><span class="line">参数：</span><br><span class="line">		-l：（line）统计行数</span><br><span class="line">		-w：（word）统计单词数</span><br><span class="line">		-c：（char）统计字符数</span><br><span class="line">例：cat 1 //会出现 2（行数）4（单词数）26（字符数）</span><br></pre></td></tr></table></figure></p>
<p>14、gzip、bzip2：压缩命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> gzip</span><br><span class="line"></span><br><span class="line"> - 压缩：</span><br><span class="line"></span><br><span class="line">	格式：gzip [-q] 文件名</span><br><span class="line">	//格式为后缀有.gz，不保留原文件</span><br><span class="line">	-q：显示高压缩比</span><br><span class="line"></span><br><span class="line"> - 解压：</span><br><span class="line"></span><br><span class="line">	格式：gzip –d 文件名</span><br><span class="line">		 gunzip 文件名</span><br><span class="line">	</span><br><span class="line">bzip2</span><br><span class="line"></span><br><span class="line">  -压缩：</span><br><span class="line"></span><br><span class="line">	格式：bzip2 [-k] 文件</span><br><span class="line">	//格式为后缀有.bz2</span><br><span class="line">	-k：（keep）产生压缩文件后保留原文件（压缩比高）</span><br><span class="line"></span><br><span class="line"> - 解压：</span><br><span class="line"></span><br><span class="line">	格式：bzip2 -d 文件名</span><br><span class="line">	     bunzip2 文件名</span><br><span class="line">zip：</span><br><span class="line"></span><br><span class="line"> - 压缩：</span><br><span class="line"></span><br><span class="line">格式：zip [-r]  [压缩后文件名称] [压缩文件或目录]   </span><br><span class="line">		 -r  压缩目录</span><br><span class="line"></span><br><span class="line"> - 解压：</span><br><span class="line"></span><br><span class="line">	格式：unzip 文件名</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190330091205658.png" alt="在这里插入图片描述"><br>15、tar：（Tape archive 解压文件）归档解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：tar [参数] 归档文件名 源文件或目录</span><br><span class="line">参数：</span><br><span class="line">	-c：创建归档文件  //扩展名为.tar</span><br><span class="line">	-v：输出详细信息</span><br><span class="line">	-f：使用归档文件</span><br><span class="line">	-x：解开归档文件</span><br><span class="line">	-t：列表查看包内文件（不释放包）</span><br><span class="line">	-p：解包时保留原始文件及目录的权限</span><br><span class="line">	-C（大写）：解包时指定释放的目录或文件夹</span><br><span class="line">	-z：调用gzip进行解压或压缩</span><br><span class="line">	-j：调用bzip2进行解压或压缩</span><br><span class="line">	-r：追加tar文件至归档结尾</span><br><span class="line">例：tar -cvf 1.tar  3 4   // 创建归档文件</span><br><span class="line">	tar -tvf 1.tar   	//查看1.tar内容</span><br><span class="line">	tar -rvf 1.tar c //将从加入1.tar</span><br><span class="line"></span><br><span class="line"> - 解压释放：</span><br><span class="line"></span><br><span class="line">	tar -zxvf 1.tar.gz		//释放gzip压缩的文件</span><br><span class="line">	tar -jxvf 1.tar.bz2		//释放bzip2压缩的文件</span><br><span class="line"></span><br><span class="line"> - 创建归档压缩文件：（或者先归档在压缩）</span><br><span class="line"></span><br><span class="line">	tar -cvzf  1.tar.gz  1 2</span><br><span class="line">	tar -cvjf  1.tar.bz2 1 2</span><br></pre></td></tr></table></figure>
<p>16、rpm：安装、升级、卸载rpm软件包<br>rpm = RPM Package Manager = RedHat Package Manager<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> - 安装</span><br><span class="line"></span><br><span class="line">格式：rpm [参数] rpm软件包</span><br><span class="line">参数：</span><br><span class="line">	-i：（install）安装一个新的rpm软件包</span><br><span class="line">	-U：（update）升级某个rpm软件包，若未安装，则安装</span><br><span class="line">	-F：更新某个rpm软件包，若原未安装，则放弃安装</span><br><span class="line">例：rpm -ivh /media/Packges/man-1.6f-29.el6.x86_64</span><br><span class="line">    rpm -qa [名] //查看安装了哪些软件，若加上名字，则查看是否安装改软件</span><br><span class="line">    rpm -qi man //查看详细信息</span><br><span class="line">    rpm -ql man //查看安装目录</span><br><span class="line"></span><br><span class="line"> - 卸载：</span><br><span class="line"></span><br><span class="line">格式：rpm -e 软件包</span><br></pre></td></tr></table></figure></p>
<p>17、diff：比较目录、文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：diff name1 name2</span><br><span class="line">文本文件格式将不同的内容列出、二进制格式只表示文件不相同</span><br></pre></td></tr></table></figure>
<p>18、more：分页显示命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：more file</span><br><span class="line">也可以用&apos;|&apos;与其他命令一起使用</span><br><span class="line">如：ls|more、ll|more</span><br></pre></td></tr></table></figure>
<p>19、tail：显示文件的最后几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：tail -n 3 ss 显示ss文件的最后3行</span><br></pre></td></tr></table></figure>
<h4 id="五、网络"><a href="#五、网络" class="headerlink" title="五、网络"></a>五、网络</h4><p>1、ifconfig：查看系统ip信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ifconfig [网络设备] [参数]</span><br><span class="line">参数：</span><br><span class="line">	up   启动指定网络设备/网卡</span><br><span class="line">	down 关闭指定网络设备/网卡</span><br><span class="line">	arp  设置指定网卡是否支持ARP协议</span><br><span class="line">	a	 （all）显示全部接口信息</span><br><span class="line">例：ifconfig eth0 查看eht0信息（eth0 表示第一块网卡）</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>网络设备</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>eth0</td>
<td>以太网</td>
</tr>
<tr>
<td>lo</td>
<td>回环设备</td>
</tr>
<tr>
<td>ppp0</td>
<td>使用ppp协议的串口设备</td>
</tr>
<tr>
<td>tr0</td>
<td>令牌环</td>
</tr>
<tr>
<td>fddi0</td>
<td>光纤2、route：查看路由表条目</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：route [-n]</span><br></pre></td></tr></table></figure>
<p>3、netstat：查看网络连接情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：netstat [参数]</span><br><span class="line">参数：</span><br><span class="line">	-a：（all）显示所有活动连接</span><br><span class="line">	-n：（number）以数字形式显示</span><br><span class="line">	-p：（process）显示进程信息</span><br><span class="line">	-t：（TCP）查看TCP协议的相关信息</span><br><span class="line">	-u：（UDP）查看UDP协议的相关信息</span><br><span class="line">	-r：（route）显示路由表信息</span><br></pre></td></tr></table></figure>
<p>4、网络接口配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位置：/etc/sysconfig/network-scripts/</span><br><span class="line">ifcfg-eth0：第一块以太网卡的配置文件</span><br><span class="line">ifcfg-eth1：第二块以太网卡的配置文件</span><br><span class="line"></span><br><span class="line">重启、关闭、启动、设置静态network网络服务</span><br><span class="line">	service network restart/stop/start/static</span><br><span class="line">启用、禁用网络接口：</span><br><span class="line">	ifdown/ifup eth0</span><br></pre></td></tr></table></figure>
<p>5、域名解析配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位置：/etc/resolv.conf</span><br><span class="line">作用：保存本机需要使用的DNS服务器的ip地址</span><br></pre></td></tr></table></figure>
<p>6、ping命令</p>
<p>7、traceroute命令：路由跟踪</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：traceroute 192.168.142.128</span><br></pre></td></tr></table></figure>
<p>8、ssh命令：远程登陆到其他UNIX主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例：ssh -l user1 192.168.1.2 //使用用户名user1登陆到192.168.1.2</span><br></pre></td></tr></table></figure>
<p>9、telnet命令：登陆到远程主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例:telnet 192.168.1.5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown学习笔记</title>
    <url>/2019/04/14/MarkDown%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="MarkDown学习笔记"><a href="#MarkDown学习笔记" class="headerlink" title="MarkDown学习笔记"></a><center>MarkDown学习笔记</center></h2><p>[TOC]</p>
<h4 id="1-目录内容"><a href="#1-目录内容" class="headerlink" title="1. 目录内容"></a>1. 目录内容</h4><h6 id="1-1-用法"><a href="#1-1-用法" class="headerlink" title="1.1 用法"></a>1.1 用法</h6><p><code>[toc]</code></p>
<h4 id="2、标题：-H1-H6"><a href="#2、标题：-H1-H6" class="headerlink" title="2、标题：(H1~H6)"></a>2、标题：(H1~H6)</h4><h6 id="2-1-用法"><a href="#2-1-用法" class="headerlink" title="2.1 用法"></a>2.1 用法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H1（#）     ctrl+1</span><br><span class="line"></span><br><span class="line">H2(##)     ctrl+2</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">H6（######） ctrl+6</span><br></pre></td></tr></table></figure>
<h6 id="2-2-例"><a href="#2-2-例" class="headerlink" title="2.2 例"></a>2.2 例</h6><p><code>##### 标题</code></p>
<p>==注：#必须在开头，且#后有空格==</p>
<h4 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h4><h6 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h6><p>开头以 &gt; 表示，可以嵌套引用</p>
<h6 id="3-2-例"><a href="#3-2-例" class="headerlink" title="3.2 例"></a>3.2 例</h6><p><code>&gt; Hello</code></p>
<h6 id="3-3-效果"><a href="#3-3-效果" class="headerlink" title="3.3 效果"></a>3.3 效果</h6><blockquote>
<p> Hello</p>
</blockquote>
<p>==&gt;必须在开头,双按换行退出==</p>
<h4 id="4、序列"><a href="#4、序列" class="headerlink" title="4、序列"></a>4、序列</h4><h5 id="4-1-无序序列"><a href="#4-1-无序序列" class="headerlink" title="4.1 无序序列"></a>4.1 无序序列</h5><h6 id="4-1-1-用法"><a href="#4-1-1-用法" class="headerlink" title="4.1.1 用法"></a>4.1.1 用法</h6><p>+/-/* 内容</p>
<h6 id="4-1-2-例"><a href="#4-1-2-例" class="headerlink" title="4.1.2 例"></a>4.1.2 例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ Red</span><br><span class="line">- Green</span><br><span class="line">* Blue</span><br></pre></td></tr></table></figure>
<h6 id="4-1-3-效果图"><a href="#4-1-3-效果图" class="headerlink" title="4.1.3 效果图"></a>4.1.3 效果图</h6><ul>
<li>red</li>
</ul>
<ul>
<li>Green</li>
</ul>
<ul>
<li>Blue</li>
</ul>
<h5 id="4-2-有序序列"><a href="#4-2-有序序列" class="headerlink" title="4.2 有序序列"></a>4.2 有序序列</h5><h6 id="4-2-1-用法"><a href="#4-2-1-用法" class="headerlink" title="4.2.1 用法"></a>4.2.1 用法</h6><p>1/2. 内容</p>
<h6 id="4-2-2-例"><a href="#4-2-2-例" class="headerlink" title="4.2.2 例"></a>4.2.2 例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Red</span><br><span class="line">2. 	Green</span><br><span class="line">3.	Blue</span><br></pre></td></tr></table></figure>
<h6 id="4-2-3-效果图"><a href="#4-2-3-效果图" class="headerlink" title="4.2.3 效果图"></a>4.2.3 效果图</h6><ol>
<li>red</li>
<li>Green</li>
<li>Blue</li>
</ol>
<h4 id="5、可选序列"><a href="#5、可选序列" class="headerlink" title="5、可选序列"></a>5、可选序列</h4><h6 id="5-1-用法"><a href="#5-1-用法" class="headerlink" title="5.1 用法"></a>5.1 用法</h6><p>*/+/- [ ] 内容</p>
<h6 id="5-2-例"><a href="#5-2-例" class="headerlink" title="5.2 例"></a>5.2 例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] a</span><br><span class="line">+ [x] b</span><br><span class="line">* [ ] c</span><br></pre></td></tr></table></figure>
<h6 id="5-3-效果"><a href="#5-3-效果" class="headerlink" title="5.3 效果"></a>5.3 效果</h6><ul>
<li style="list-style: none"><input type="checkbox"> a</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox" checked> b</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox"> c</li>
</ul>
<p>==‘[’ 与‘]’之间要有一个空格==</p>
<h4 id="6、代码块"><a href="#6、代码块" class="headerlink" title="6、代码块"></a>6、代码块</h4><h6 id="6-1-用法"><a href="#6-1-用法" class="headerlink" title="6.1 用法"></a>6.1 用法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​```[语言]</span><br></pre></td></tr></table></figure>
<h6 id="6-2-例"><a href="#6-2-例" class="headerlink" title="6.2 例"></a>6.2 例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​```java</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### 6.3 效果：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7、行内代码"><a href="#7、行内代码" class="headerlink" title="7、行内代码"></a>7、行内代码</h4><h6 id="7-1-用法"><a href="#7-1-用法" class="headerlink" title="7.1 用法"></a>7.1 用法</h6><p>用两个在正段落中表示代码</p>
<h6 id="7-2-例"><a href="#7-2-例" class="headerlink" title="7.2 例"></a>7.2 例</h6><p>use the <code>printf()</code> function;</p>
<h4 id="8、数学块"><a href="#8、数学块" class="headerlink" title="8、数学块"></a>8、数学块</h4><h6 id="8-1-用法"><a href="#8-1-用法" class="headerlink" title="8.1 用法"></a>8.1 用法</h6><p>以$$开头</p>
<h6 id="8-2-例"><a href="#8-2-例" class="headerlink" title="8.2 例"></a>8.2 例</h6><p><code>$$</code></p>
<p><code>\lim_{x \to \infty} \exp(-x) = 0</code></p>
<p><code>$$</code></p>
<h6 id="8-7-效果"><a href="#8-7-效果" class="headerlink" title="8.7 效果"></a>8.7 效果</h6><p>$$<br>$\lim_{x \to \infty} \exp(-x) = 0$<br>$$</p>
<h4 id="9、行内数学公式"><a href="#9、行内数学公式" class="headerlink" title="9、行内数学公式"></a>9、行内数学公式</h4><h6 id="9-1-用法"><a href="#9-1-用法" class="headerlink" title="9.1 用法"></a>9.1 用法</h6><p>以$开头</p>
<h6 id="9-2例"><a href="#9-2例" class="headerlink" title="9.2例"></a>9.2例</h6><p><code>$\lim_{x \to \infty} \exp(-x) = 0$</code></p>
<h6 id="9-3-效果"><a href="#9-3-效果" class="headerlink" title="9.3 效果"></a>9.3 效果</h6><p>$\lim_{x \to \infty} \exp(-x) = 0$</p>
<h4 id="10、表格："><a href="#10、表格：" class="headerlink" title="10、表格："></a>10、表格：</h4><h6 id="10-1-用法"><a href="#10-1-用法" class="headerlink" title="10.1 用法"></a>10.1 用法</h6><p>以|为分割线，划分表格 </p>
<h6 id="10-2-例"><a href="#10-2-例" class="headerlink" title="10.2 例"></a>10.2 例</h6><p><code>|1|2|3|4|</code></p>
<h6 id="10-3-效果"><a href="#10-3-效果" class="headerlink" title="10.3 效果"></a>10.3 效果</h6><table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="11、脚注"><a href="#11、脚注" class="headerlink" title="11、脚注"></a>11、脚注</h4><h6 id="11-1-用法"><a href="#11-1-用法" class="headerlink" title="11.1 用法"></a>11.1 用法</h6><p><code>[^footnode]</code></p>
<h6 id="11-2-例"><a href="#11-2-例" class="headerlink" title="11.2 例"></a>11.2 例</h6><p><code>脚注[^1]</code></p>
<p><code>[^1]:解释</code></p>
<h6 id="11-3-效果"><a href="#11-3-效果" class="headerlink" title="11.3 效果"></a>11.3 效果</h6><p>脚注<a href="解释">^1</a> </p>
<h4 id="12、分割线"><a href="#12、分割线" class="headerlink" title="12、分割线"></a>12、分割线</h4><h6 id="12-1-用法"><a href="#12-1-用法" class="headerlink" title="12.1 用法"></a>12.1 用法</h6><p>***或者—</p>
<h6 id="12-2-例"><a href="#12-2-例" class="headerlink" title="12.2 例"></a>12.2 例</h6><p><code>***</code></p>
<p>12.3 效果</p>
<hr>
<h4 id="13、YAML-Front-Matter-2"><a href="#13、YAML-Front-Matter-2" class="headerlink" title="13、YAML Front Matter[^2]"></a>13、YAML Front Matter[^2]</h4><p>[^2]:YAML是一个人性化的数据序列化,是所有编程语言的标准。为了能方便的保存文章的元数据，几乎所有的静态网站生成器都使用front matter格式来保存文章。front matter文件通常分为头部和正文部分，头部一般使用yaml、toml和json三种格式，front matter 解析工具需要识别这三种格式的文件头。正文部分就是普通的Markdown 内容。</p>
<h6 id="13-1-用法"><a href="#13-1-用法" class="headerlink" title="13.1 用法"></a>13.1 用法</h6><p>在开头输入—</p>
<h6 id="13-2-效果"><a href="#13-2-效果" class="headerlink" title="13.2 效果"></a>13.2 效果</h6><p><img src="D:\Typora\笔记\捕获.PNG" alt="捕获"></p>
<h4 id="14、链接"><a href="#14、链接" class="headerlink" title="14、链接"></a>14、链接</h4><h5 id="14-1-内链"><a href="#14-1-内链" class="headerlink" title="14.1 内链"></a>14.1 内链</h5><h6 id="14-1-1-用法"><a href="#14-1-1-用法" class="headerlink" title="14.1.1 用法"></a>14.1.1 用法</h6><p><code>[链接内容](链接源 &quot;title&quot;)</code></p>
<h6 id="14-1-2-例"><a href="#14-1-2-例" class="headerlink" title="14.1.2 例"></a>14.1.2 例</h6><p><code>[Baidu](https://www.baidu.com &quot;Baidu&quot;)</code></p>
<h6 id="14-1-3-效果"><a href="#14-1-3-效果" class="headerlink" title="14.1.3 效果"></a>14.1.3 效果</h6><p><a href="http://www.baidu.com" title="Baidu" target="_blank" rel="noopener">Baidu</a></p>
<p>==title需要加引号==</p>
<h5 id="14-2-引用链接"><a href="#14-2-引用链接" class="headerlink" title="14.2 引用链接"></a>14.2 引用链接</h5><h6 id="14-2-1-用法"><a href="#14-2-1-用法" class="headerlink" title="14.2.1 用法"></a>14.2.1 用法</h6><p><code>[链接内容][id]</code></p>
<p><code>[id]:链接源 &quot;title&quot;</code></p>
<h6 id="14-2-2-例"><a href="#14-2-2-例" class="headerlink" title="14.2.2 例"></a>14.2.2 例</h6><p><code>[Baidu][id]</code></p>
<p><code>[id]:http://www.baidu.com &quot;Baidu&quot;</code></p>
<h6 id="14-2-3-效果"><a href="#14-2-3-效果" class="headerlink" title="14.2.3 效果"></a>14.2.3 效果</h6><p><a href="http://www.baidu.com" title="Baidu" target="_blank" rel="noopener">Baidu</a></p>
<h4 id="15、URLs"><a href="#15、URLs" class="headerlink" title="15、URLs"></a>15、URLs</h4><p>15.1 用法</p>
<p>用&lt;&gt;括住URL</p>
<p>==对于标准URL，可自动识别==</p>
<h6 id="15-2-例"><a href="#15-2-例" class="headerlink" title="15.2 例"></a>15.2 例</h6><p><code>www.baidu.com</code></p>
<p><code>&lt;i@163.com&gt;</code></p>
<h6 id="15-3-效果"><a href="#15-3-效果" class="headerlink" title="15.3 效果"></a>15.3 效果</h6><p><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><a href="mailto:&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#105;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></p>
<h4 id="16、图片"><a href="#16、图片" class="headerlink" title="16、图片"></a>16、图片</h4><h6 id="16-1-用法"><a href="#16-1-用法" class="headerlink" title="16.1 用法"></a>16.1 用法</h6><ol>
<li>手动添加，前面加!，格式类似链接</li>
<li>用鼠标将图片拖入</li>
</ol>
<h6 id="16-2-例"><a href="#16-2-例" class="headerlink" title="16.2 例"></a>16.2 例</h6><p><code>![截图](D:\Typora\笔记\1.jpg &quot;截图&quot;)</code></p>
<h6 id="16-3-效果"><a href="#16-3-效果" class="headerlink" title="16.3 效果"></a>16.3 效果</h6><p><img src="D:\Typora\笔记\1.jpg" alt="无标题" title="截图"></p>
<h4 id="17、斜体"><a href="#17、斜体" class="headerlink" title="17、斜体"></a>17、斜体</h4><h6 id="17-1-用法"><a href="#17-1-用法" class="headerlink" title="17.1 用法"></a>17.1 用法</h6><p>以<em> </em>或_ _括住</p>
<h6 id="17-2-例"><a href="#17-2-例" class="headerlink" title="17.2 例"></a>17.2 例</h6><p><code>*example*  _example_</code> </p>
<h6 id="17-3-效果"><a href="#17-3-效果" class="headerlink" title="17.3 效果"></a>17.3 效果</h6><p><em>example</em> <em>example</em></p>
<h4 id="18、加粗"><a href="#18、加粗" class="headerlink" title="18、加粗"></a>18、加粗</h4><h6 id="18-1-用法"><a href="#18-1-用法" class="headerlink" title="18.1 用法"></a>18.1 用法</h6><p>以双<em>或双_开头，以双</em>或双_结尾</p>
<p>例：<code>**example** __example__</code></p>
<h6 id="18-2-效果"><a href="#18-2-效果" class="headerlink" title="18.2 效果"></a>18.2 效果</h6><p><strong>example</strong> <strong>example</strong></p>
<h4 id="19、删除线"><a href="#19、删除线" class="headerlink" title="19、删除线"></a>19、删除线</h4><h6 id="19-1-用法"><a href="#19-1-用法" class="headerlink" title="19.1 用法"></a>19.1 用法</h6><p>以两个<code>~</code>开头，两个<code>~</code>结尾</p>
<h6 id="19-2-例"><a href="#19-2-例" class="headerlink" title="19.2 例"></a>19.2 例</h6><p><code>~example~</code></p>
<h6 id="19-3-效果"><a href="#19-3-效果" class="headerlink" title="19.3 效果"></a>19.3 效果</h6><p><del>example</del></p>
<h4 id="20、下划线"><a href="#20、下划线" class="headerlink" title="20、下划线"></a>20、下划线</h4><h6 id="20-1-用法"><a href="#20-1-用法" class="headerlink" title="20.1 用法"></a>20.1 用法</h6><p><code>&lt;u&gt; &lt;/u&gt;</code></p>
<h6 id="20-2-例"><a href="#20-2-例" class="headerlink" title="20.2 例"></a>20.2 例</h6><p><code>&lt;u&gt;example&lt;/u&gt;</code></p>
<p>20.3 效果</p>
<p><u>example</u></p>
<h4 id="21、表情"><a href="#21、表情" class="headerlink" title="21、表情"></a>21、表情</h4><h6 id="21-1-用法"><a href="#21-1-用法" class="headerlink" title="21.1 用法"></a>21.1 用法</h6><p>:表情单词:</p>
<h6 id="21-2-例"><a href="#21-2-例" class="headerlink" title="21.2 例"></a>21.2 例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:smile:</span><br><span class="line">:angry:</span><br><span class="line">:happy:</span><br><span class="line">:cry:</span><br><span class="line">:weary:			//疲倦的</span><br><span class="line">:flushed:		//兴奋的</span><br><span class="line">:imp:			//魔鬼</span><br></pre></td></tr></table></figure>
<p>21.3 效果</p>
<blockquote>
<p>:smile:<br>:angry:<br>:happy:<br>:cry:<br>:weary:<br>:flushed:<br>:imp:</p>
</blockquote>
<h4 id="22、下标"><a href="#22、下标" class="headerlink" title="22、下标"></a>22、下标</h4><h6 id="22-1-用法"><a href="#22-1-用法" class="headerlink" title="22.1 用法"></a>22.1 用法</h6><p>使用双~括住内容</p>
<h6 id="22-2-例"><a href="#22-2-例" class="headerlink" title="22.2 例"></a>22.2 例</h6><p><code>H~2~0</code></p>
<h6 id="22-3-效果"><a href="#22-3-效果" class="headerlink" title="22.3 效果"></a>22.3 效果</h6><p>H~2~o</p>
<h4 id="23、上标"><a href="#23、上标" class="headerlink" title="23、上标"></a>23、上标</h4><h6 id="23-1-用法"><a href="#23-1-用法" class="headerlink" title="23.1 用法"></a>23.1 用法</h6><p>使用双^括住内容</p>
<h6 id="23-2-例"><a href="#23-2-例" class="headerlink" title="23.2 例"></a>23.2 例</h6><p><code>x^2^</code></p>
<h6 id="23-3-效果"><a href="#23-3-效果" class="headerlink" title="23.3 效果"></a>23.3 效果</h6><p>x^2^</p>
<h4 id="24、高亮"><a href="#24、高亮" class="headerlink" title="24、高亮"></a>24、高亮</h4><h6 id="24-1-用法"><a href="#24-1-用法" class="headerlink" title="24.1 用法"></a>24.1 用法</h6><p>使用双==括住内容</p>
<h6 id="24-2-例"><a href="#24-2-例" class="headerlink" title="24.2 例"></a>24.2 例</h6><p><code>==asd==</code></p>
<h6 id="24-3-效果"><a href="#24-3-效果" class="headerlink" title="24.3 效果"></a>24.3 效果</h6><p>==asd==</p>
<h4 id="25、HTML"><a href="#25、HTML" class="headerlink" title="25、HTML"></a>25、HTML</h4><h6 id="25-1-例"><a href="#25-1-例" class="headerlink" title="25.1 例"></a>25.1 例</h6><p><code>&lt;span style=&quot;color:red&quot;&gt;example&lt;/span&gt;</code></p>
<h6 id="25-2-效果"><a href="#25-2-效果" class="headerlink" title="25.2 效果"></a>25.2 效果</h6><p><span style="color:red">example</span></p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2019/04/13/%E7%BB%93%E5%90%88Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="重点-：千万记得改根设置和主题设置以及其他的一些东西之前把你不清楚的备份一下，免得你到时候出错了又不知道哪里出错了不知道怎么办"><a href="#重点-：千万记得改根设置和主题设置以及其他的一些东西之前把你不清楚的备份一下，免得你到时候出错了又不知道哪里出错了不知道怎么办" class="headerlink" title="==重点==：千万记得改根设置和主题设置以及其他的一些东西之前把你不清楚的备份一下，免得你到时候出错了又不知道哪里出错了不知道怎么办"></a>==重点==：千万记得改根设置和主题设置以及其他的一些东西之前把你不清楚的备份一下，免得你到时候出错了又不知道哪里出错了不知道怎么办</h4><h5 id="我当初就是年少无知，跟着教程改了一些东西，然后他的和我的一些配置啊，版本啊不一样，结果导致在我的上面不能运行，然后还导致博客页面啥也没有。。。我就把原来的设置全部删除，重新下载，然后重新设置配置。。。说起来都是泪啊"><a href="#我当初就是年少无知，跟着教程改了一些东西，然后他的和我的一些配置啊，版本啊不一样，结果导致在我的上面不能运行，然后还导致博客页面啥也没有。。。我就把原来的设置全部删除，重新下载，然后重新设置配置。。。说起来都是泪啊" class="headerlink" title="我当初就是年少无知，跟着教程改了一些东西，然后他的和我的一些配置啊，版本啊不一样，结果导致在我的上面不能运行，然后还导致博客页面啥也没有。。。我就把原来的设置全部删除，重新下载，然后重新设置配置。。。说起来都是泪啊"></a>我当初就是年少无知，跟着教程改了一些东西，然后他的和我的一些配置啊，版本啊不一样，结果导致在我的上面不能运行，然后还导致博客页面啥也没有。。。我就把原来的设置全部删除，重新下载，然后重新设置配置。。。说起来都是泪啊</h5><p>推荐一些我觉得写的好的搭建博客的教程啦(我把推荐写在前面，就免得你们还看我的 -_-||)</p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">Hexo博客优化之Next主题美化</a></p>
<p><a href="https://blog.csdn.net/qq_33699981/article/details/72716951" target="_blank" rel="noopener">hexo的next主题个性化教程：打造炫酷网站</a></p>
<p><a href="https://www.jianshu.com/p/c311d31265e0" target="_blank" rel="noopener">hexo页脚添加访客人数和总访问量</a></p>
<h3 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h3><h4 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h4><ol>
<li>搭建Node.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试安装：node -v</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装Hexo工具</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h4 id="2、搭建博客"><a href="#2、搭建博客" class="headerlink" title="2、搭建博客"></a>2、搭建博客</h4><ol>
<li><p>开启GitHub Pages服务</p>
<p>（创建了一个默认的博客页，并且得到了一个可外部访问的域名）</p>
<p>通过Github Pages获得一个免费使用的域名，需要在Github上新建一个仓库</p>
<p>新仓库的名字，一定要是UserName+“github.io”</p>
<p>在设置中找到GitHub Pages点击Choose theme选择一个主题</p>
<p>再进入GitHub Pages中会得到一个域名<a href="https://oouapatia.github.io/" target="_blank" rel="noopener">https://oouapatia.github.io/</a></p>
</li>
<li><p>创建本地博客点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init  Blog</span><br></pre></td></tr></table></figure>
<p>测试本地博客站点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g  //g是generetor的缩写，生成博客</span><br><span class="line">hexo s  //s是server的缩写，启动服务</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步到Github</p>
<p>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:oouapatia/oouapatia.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>执行控制台命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3、发布博客"><a href="#3、发布博客" class="headerlink" title="3、发布博客"></a>3、发布博客</h4><p>在本地博客文件夹根目录输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;</span><br><span class="line">hexo g   //生成网页</span><br><span class="line">hexo d  //部署到远端(github)</span><br></pre></td></tr></table></figure>
<p>找到_posts里的博客原文，先编辑内容，然后再部署到github上</p>
<h4 id="4、更换主题"><a href="#4、更换主题" class="headerlink" title="4、更换主题"></a>4、更换主题</h4><ol>
<li>在themes文件夹下新建一个next存放即将下载的主题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir themes\next</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>下载主题</p>
<p><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p>
<p><a href="https://github.com/topics/hexo" target="_blank" rel="noopener">https://github.com/topics/hexo</a></p>
</li>
<li><p>修改博客配置文件，更换主题</p>
</li>
</ol>
<p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>在控制台下输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  //清理缓存</span><br><span class="line">hexo g    //重新生成博客代码</span><br><span class="line">hexo d   //部署到本地</span><br></pre></td></tr></table></figure>
<p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next 设置</a></p>
<h4 id="5、大的几个坑"><a href="#5、大的几个坑" class="headerlink" title="5、大的几个坑"></a>5、大的几个坑</h4><ol>
<li>hexo g报错：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Process failed: _posts/my.md</span><br><span class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1:</span><br></pre></td></tr></table></figure>
<p>解决：查看新建要上传地md文件，tags或者其他，与后面内容是不是有一个空格。 </p>
<ol start="2">
<li>npm install报错</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fsevent是mac osx系统的，在win或者Linux下使用了 所以会有警告，忽略即可。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>hexo d报错</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要提前安装一个扩展npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置文件_config.yml</li>
</ol>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置文件里的deploy中的设置，：后面也需要有空格，不然无法进行部署</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在修改主题是遇到的问题</li>
</ol>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改_config.yml中的language为zh-Hans时，在notepad++默认的方式输入中文，然后到浏览器中运行，发现乱码。回去查看notepad++中的默认字符是ANSI编码，转化为UTF-8后，原来输入的中文乱码`ʰǢ`,将原来输入的文字在UTF-8模式下重新输入。</span><br></pre></td></tr></table></figure>
<h4 id="6、结"><a href="#6、结" class="headerlink" title="6、结"></a>6、结</h4><p>啊。。</p>
<p>我搭从星期三晚上开始搭博客，遇到各种bug，看了一晚上，头都大了，还是没有解决，便放到了星期四早上，从十点一直搭到下午两点上课，把node卸了好几遍，又重新装了好几遍，还是有各种bug，而且比原来还多……-_-||</p>
<p>后来去做别的事，一直放到了星期六，本来是有点被它们看懵了的，星期六下午学了会儿Python后，想了想，还是不能放弃才行，于是又开始搭建博客，仔细阅读网上的教程，一步步搭建，结果还是有很多错误，其中有一些，仔细看它的提示信息，在网上搜索一番，发现这些警告并没有什么影响，如fsevent，只是因为操作系统的缘故发出了警告。随后又在网上的一篇博客中找到了很多问题的解决方案。<a href="https://blog.csdn.net/u010629610/article/details/84573402" target="_blank" rel="noopener">cloud_yf</a></p>
<p>又在搜索中发现了<a href="(&lt;https://hexo.io/zh-cn/docs/">Hexo</a>)的官网,我忽略了Hexo的官网这个大助功，里面有很多的操作和原理，还有很多的主题。</p>
<p>这次搭建博客最大的感受就是碰见问题一定不能退缩，不想做了可以放下来换换别的事情，在心情平静下来后再继续</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2019/04/13/Welcome/</url>
    <content><![CDATA[<h3 id="Welcome-to-my-blog！"><a href="#Welcome-to-my-blog！" class="headerlink" title="Welcome to my blog！"></a>Welcome to my blog！</h3><ul>
<li><p>结合Hexo建的博客</p>
</li>
<li><p>将自己的笔记发到博客上</p>
</li>
<li><p>分享自己的学习笔记</p>
</li>
<li><p>记录自己的学习经历</p>
</li>
<li><p>没事来瞅瞅</p>
</li>
<li>有事来看看</li>
<li>弟弟行径</li>
<li>先筹一下字数</li>
</ul>
]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
